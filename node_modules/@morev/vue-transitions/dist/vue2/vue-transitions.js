import { isObject, isInteger, isString, isNumeric, clamp, isArray } from "@morev/utils";
const validateEnterLeave = (value, validator) => {
  if (validator(value))
    return true;
  if (!isObject(value))
    return false;
  if (Object.keys(value).length !== 2)
    return false;
  return !Object.entries(value).some(([key, val]) => {
    const wrongKey = !["enter", "leave"].includes(key);
    const wrongValue = !validator(val);
    return wrongKey || wrongValue;
  });
};
const validateDuration = (value) => validateEnterLeave(value, (val) => {
  return isInteger(val) && val >= 0;
});
const validateEasing = (value) => validateEnterLeave(value, (val) => {
  return isString(val) && val.trim() !== "";
});
const validateDelay = (value) => validateEnterLeave(value, (val) => {
  return isInteger(val) && val >= 0;
});
const transitionDuration = 300;
const transitionEasing = "cubic-bezier(.25, .8, .5, 1)";
const transitionDelay = 0;
const expandAxis = "y";
const slideOffset = [0, -16];
const scaleAxis = "both";
const scaleOrigin = "50% 50%";
const scaleValue = 0;
const moveDuration = transitionDuration;
const baseTransition = {
  inheritAttrs: false,
  props: {
    duration: {
      validator: validateDuration,
      default: transitionDuration
    },
    easing: {
      validator: validateEasing,
      default: () => transitionEasing
    },
    delay: {
      validator: validateDelay,
      default: transitionDelay
    },
    noOpacity: {
      type: Boolean,
      default: false
    },
    appear: {
      type: Boolean,
      default: false
    },
    mode: {
      type: String,
      default: void 0
    },
    group: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: "span"
    },
    noMove: {
      type: Boolean,
      default: false
    },
    moveDuration: {
      type: Number,
      default: moveDuration
    }
  },
  computed: {
    cComponent() {
      return this.group ? "transition-group" : "transition";
    },
    cAttrs() {
      const { appear, mode, tag, duration } = this;
      return this.group ? { appear, tag, duration, ...this.$attrs } : { appear, mode, duration };
    },
    cHooks() {
      return {
        ...this.$listeners,
        beforeEnter: (...args) => {
          this.reduceTransition(...args);
          this.$emit("before-enter", ...args);
        },
        beforeLeave: (...args) => {
          var _a;
          this.reduceTransition(...args);
          (_a = this.initLeaving) == null ? void 0 : _a.call(this, ...args);
          this.$emit("before-leave", ...args);
        },
        enter: (...args) => {
          var _a;
          (_a = this.onEnter) == null ? void 0 : _a.call(this, ...args);
          this.$emit("enter", ...args);
        },
        leave: (...args) => {
          var _a;
          (_a = this.onLeave) == null ? void 0 : _a.call(this, ...args);
          this.$emit("leave", ...args);
        },
        afterEnter: (...args) => {
          var _a;
          this.resetTransition(...args);
          (_a = this.resetElement) == null ? void 0 : _a.call(this, ...args);
          this.$emit("after-enter", ...args);
        },
        afterLeave: (...args) => {
          var _a;
          this.resetTransition(...args);
          (_a = this.resetElement) == null ? void 0 : _a.call(this, ...args);
          this.$emit("after-leave", ...args);
        }
      };
    }
  },
  methods: {
    setupTransition(element, event = "enter") {
      var _a, _b, _c;
      const duration = ((_a = this.duration) == null ? void 0 : _a[event]) ?? this.duration;
      const easing = ((_b = this.easing) == null ? void 0 : _b[event]) ?? this.easing;
      const delay = ((_c = this.delay) == null ? void 0 : _c[event]) ?? this.delay;
      element.style.setProperty("transition-duration", `${duration}ms`, "important");
      element.style.setProperty("transition-timing-function", `${easing}`, "important");
      element.style.setProperty("transition-delay", `${delay}ms`, "important");
    },
    reduceTransition(element) {
      element.style.setProperty("transition-duration", "0ms", "important");
      element.style.setProperty("transition-delay", "0ms", "important");
    },
    resetTransition(element) {
      element.style.removeProperty("transition-duration");
      element.style.removeProperty("transition-timing-function");
      element.style.removeProperty("transition-delay");
    },
    initLeaving(element) {
      if (!this.group || this.noMove)
        return element;
      const styles = getComputedStyle(element);
      const { width, height } = styles;
      const { marginLeft, marginTop } = styles;
      element.style.setProperty("left", `${element.offsetLeft - parseFloat(marginLeft)}px`, "important");
      element.style.setProperty("top", `${element.offsetTop - parseFloat(marginTop)}px`, "important");
      element.style.setProperty("width", `${parseFloat(width)}px`, "important");
      element.style.setProperty("height", `${parseFloat(height)}px`, "important");
      element.style.setProperty("position", "absolute", "important");
      return element;
    },
    setMoveDuration() {
      var _a;
      if (this.group && this.$el) {
        (_a = this.$el.style) == null ? void 0 : _a.setProperty("--move-duration", `${this.moveDuration}ms`);
      }
    }
  },
  watch: {
    moveDuration() {
      this.setMoveDuration();
    },
    group() {
      this.setMoveDuration();
    }
  },
  mounted() {
    this.setMoveDuration();
  }
};
const validateExpandAxis = (value) => validateEnterLeave(value, (val) => {
  return isString(val) && ["x", "y"].includes(val);
});
var render$3 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.cComponent, _vm._g(_vm._b({
    tag: "component",
    attrs: {
      "name": "expand"
    }
  }, "component", _vm.cAttrs, false), _vm.cHooks), [_vm._t("default")], 2);
};
var staticRenderFns$3 = [];
function normalizeComponent(scriptExports, render2, staticRenderFns2, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {
  var options = typeof scriptExports === "function" ? scriptExports.options : scriptExports;
  if (render2) {
    options.render = render2;
    options.staticRenderFns = staticRenderFns2;
    options._compiled = true;
  }
  if (functionalTemplate) {
    options.functional = true;
  }
  if (scopeId) {
    options._scopeId = "data-v-" + scopeId;
  }
  var hook;
  if (moduleIdentifier) {
    hook = function(context) {
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
      if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
        context = __VUE_SSR_CONTEXT__;
      }
      if (injectStyles) {
        injectStyles.call(this, context);
      }
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    };
    options._ssrRegister = hook;
  } else if (injectStyles) {
    hook = shadowMode ? function() {
      injectStyles.call(
        this,
        (options.functional ? this.parent : this).$root.$options.shadowRoot
      );
    } : injectStyles;
  }
  if (hook) {
    if (options.functional) {
      options._injectStyles = hook;
      var originalRender = options.render;
      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }
  return {
    exports: scriptExports,
    options
  };
}
const __vue2_script$3 = {
  name: "transition-expand",
  mixins: [
    baseTransition
  ],
  props: {
    axis: {
      validator: validateExpandAxis,
      default: expandAxis
    }
  },
  data: () => ({}),
  computed: {},
  methods: {
    async onEnter(element) {
      await this.$nextTick();
      await this.$nextTick();
      this.getSizes(element);
      this.collapseElement(element, "enter");
      element.offsetTop;
      this.setupTransition(element, "enter");
      this.expandElement(element, "enter");
    },
    onLeave(element) {
      this.getSizes(element);
      this.expandElement(element, "leave");
      element.offsetTop;
      this.setupTransition(element, "leave");
      this.collapseElement(element, "leave");
    },
    expandElement(element, event = "enter") {
      var _a;
      const axis = ((_a = this.axis) == null ? void 0 : _a[event]) ?? this.axis;
      const start = axis === "x" ? "left" : "top";
      const end = axis === "x" ? "right" : "bottom";
      const size = element.visual.size[axis];
      const margin = element.visual.margin[axis];
      const padding = element.visual.padding[axis];
      if (!this.noOpacity) {
        element.style.setProperty("opacity", element.visual.opacity);
      }
      delete element.visual;
      element.style.setProperty(axis === "x" ? "width" : "height", `${parseFloat(size)}px`);
      element.style.setProperty(`padding-${start}`, `${parseFloat(padding[0])}px`);
      element.style.setProperty(`padding-${end}`, `${parseFloat(padding[1])}px`);
      element.style.setProperty(`margin-${start}`, `${parseFloat(margin[0])}px`);
      element.style.setProperty(`margin-${end}`, `${parseFloat(margin[1])}px`);
    },
    collapseElement(element, event = "enter") {
      var _a;
      const axis = ((_a = this.axis) == null ? void 0 : _a[event]) ?? this.axis;
      const axisProp = axis === "x" ? "width" : "height";
      const start = axis === "x" ? "left" : "top";
      const end = axis === "x" ? "right" : "bottom";
      if (!this.noOpacity) {
        element.style.setProperty("opacity", 0);
      }
      element.style.setProperty(axisProp, "0px");
      element.style.setProperty(`padding-${start}`, "0px");
      element.style.setProperty(`padding-${end}`, "0px");
      element.style.setProperty(`margin-${start}`, "0px");
      element.style.setProperty(`margin-${end}`, "0px");
    },
    resetElement(element) {
      element.style.removeProperty("opacity");
      element.style.removeProperty("width");
      element.style.removeProperty("height");
      element.style.removeProperty("padding-top");
      element.style.removeProperty("padding-right");
      element.style.removeProperty("padding-bottom");
      element.style.removeProperty("padding-left");
      element.style.removeProperty("margin-top");
      element.style.removeProperty("margin-right");
      element.style.removeProperty("margin-bottom");
      element.style.removeProperty("margin-left");
    },
    getSizes(element) {
      const styles = getComputedStyle(element);
      const { opacity } = styles;
      const { width, height } = styles;
      const { paddingTop, paddingRight, paddingBottom, paddingLeft } = styles;
      const { marginTop, marginRight, marginBottom, marginLeft } = styles;
      element.visual = {
        opacity,
        size: { x: width, y: height },
        padding: { x: [paddingLeft, paddingRight], y: [paddingTop, paddingBottom] },
        margin: { x: [marginLeft, marginRight], y: [marginTop, marginBottom] }
      };
    }
  }
};
const __cssModules$3 = {};
var __component__$3 = /* @__PURE__ */ normalizeComponent(
  __vue2_script$3,
  render$3,
  staticRenderFns$3,
  false,
  __vue2_injectStyles$3,
  null,
  null,
  null
);
function __vue2_injectStyles$3(context) {
  for (let o in __cssModules$3) {
    this[o] = __cssModules$3[o];
  }
}
const TransitionExpand = /* @__PURE__ */ function() {
  return __component__$3.exports;
}();
var render$2 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.cComponent, _vm._g(_vm._b({
    tag: "component",
    attrs: {
      "name": "fade"
    }
  }, "component", _vm.cAttrs, false), _vm.cHooks), [_vm._t("default")], 2);
};
var staticRenderFns$2 = [];
const __vue2_script$2 = {
  name: "transition-fade",
  mixins: [
    baseTransition
  ],
  props: {},
  data: () => ({}),
  computed: {},
  methods: {
    onEnter(element) {
      this.fadeElement(element, "enter");
      element.offsetTop;
      this.setupTransition(element, "enter");
      this.$nextTick(() => element.style.removeProperty("opacity"));
    },
    onLeave(element) {
      this.setupTransition(element, "leave");
      this.fadeElement(element, "leave");
    },
    fadeElement(element, event = "enter") {
      element.style.setProperty("opacity", 0);
    },
    resetElement(element) {
      element.style.removeProperty("opacity");
    }
  }
};
const __cssModules$2 = {};
var __component__$2 = /* @__PURE__ */ normalizeComponent(
  __vue2_script$2,
  render$2,
  staticRenderFns$2,
  false,
  __vue2_injectStyles$2,
  null,
  null,
  null
);
function __vue2_injectStyles$2(context) {
  for (let o in __cssModules$2) {
    this[o] = __cssModules$2[o];
  }
}
const TransitionFade = /* @__PURE__ */ function() {
  return __component__$2.exports;
}();
const validateScaleAxis = (value) => validateEnterLeave(value, (val) => {
  return isString(val) && ["x", "y", "both"].includes(val);
});
const validateScaleOrigin = (value) => validateEnterLeave(value, (val) => {
  return isString(val) && val.trim() !== "";
});
const validateScaleValue = (value) => validateEnterLeave(value, (val) => {
  return isNumeric(val) && val >= 0 && val <= 1;
});
const getMatrix = (transform) => {
  const matrixType = transform.startsWith("matrix3d") ? "matrix3d" : "matrix";
  const matrix = matrixType === "matrix3d" ? transform.slice(9, -1).split(",").map(Number) : transform.startsWith("matrix") ? transform.slice(7, -1).split(",").map(Number) : [1, 0, 0, 1, 0, 0];
  return [matrixType, matrix];
};
var render$1 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.cComponent, _vm._g(_vm._b({
    tag: "component",
    attrs: {
      "name": "scale"
    }
  }, "component", _vm.cAttrs, false), _vm.cHooks), [_vm._t("default")], 2);
};
var staticRenderFns$1 = [];
const __vue2_script$1 = {
  name: "transition-scale",
  mixins: [
    baseTransition
  ],
  props: {
    axis: {
      validator: validateScaleAxis,
      default: scaleAxis
    },
    origin: {
      validator: validateScaleOrigin,
      default: scaleOrigin
    },
    scale: {
      validator: validateScaleValue,
      default: scaleValue
    }
  },
  data: () => ({}),
  computed: {},
  methods: {
    onEnter(element) {
      this.scaleElement(element, "enter");
      element.offsetTop;
      this.setupTransition(element, "enter");
      this.$nextTick(() => {
        element.style.removeProperty("opacity");
        element.style.removeProperty("transform");
      });
    },
    onLeave(element) {
      this.setupTransition(element, "leave");
      this.scaleElement(element, "leave");
    },
    scaleElement(element, event = "enter") {
      var _a, _b, _c;
      const { transform } = getComputedStyle(element);
      const axis = ((_a = this.axis) == null ? void 0 : _a[event]) ?? this.axis;
      const origin = ((_b = this.origin) == null ? void 0 : _b[event]) ?? this.origin;
      const scale = clamp(1e-4, ((_c = this.scale) == null ? void 0 : _c[event]) ?? this.scale, 0.9999);
      const [matrixType, matrix] = getMatrix(transform);
      if (transform.startsWith("matrix3d")) {
        if (axis !== "y")
          matrix[0] = scale;
        if (axis !== "x")
          matrix[5] = scale;
      } else if (transform.startsWith("matrix")) {
        if (axis !== "y")
          matrix[0] = scale;
        if (axis !== "x")
          matrix[3] = scale;
      } else {
        matrix[0] = axis === "y" ? 1 : scale;
        matrix[3] = axis === "x" ? 1 : scale;
      }
      if (!this.noOpacity) {
        element.style.setProperty("opacity", 0);
      }
      element.style.setProperty("transform", `${matrixType}(${matrix})`);
      element.style.setProperty("transform-origin", `${origin}`);
    },
    resetElement(element) {
      element.style.removeProperty("opacity");
      element.style.removeProperty("transform");
      element.style.removeProperty("transform-origin");
    }
  }
};
const __cssModules$1 = {};
var __component__$1 = /* @__PURE__ */ normalizeComponent(
  __vue2_script$1,
  render$1,
  staticRenderFns$1,
  false,
  __vue2_injectStyles$1,
  null,
  null,
  null
);
function __vue2_injectStyles$1(context) {
  for (let o in __cssModules$1) {
    this[o] = __cssModules$1[o];
  }
}
const TransitionScale = /* @__PURE__ */ function() {
  return __component__$1.exports;
}();
const validateSlideOffset = (value) => validateEnterLeave(value, (val) => {
  if (!isArray(val))
    return false;
  if (val.length !== 2)
    return false;
  return !val.some((v) => {
    if (isInteger(v))
      return false;
    if (isString(v)) {
      return isNaN(Number(v.endsWith("%") ? v.slice(0, -1) : v));
    }
    return true;
  });
});
var render = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.cComponent, _vm._g(_vm._b({
    tag: "component",
    attrs: {
      "name": "slide"
    }
  }, "component", _vm.cAttrs, false), _vm.cHooks), [_vm._t("default")], 2);
};
var staticRenderFns = [];
const __vue2_script = {
  name: "transition-slide",
  mixins: [
    baseTransition
  ],
  props: {
    offset: {
      validator: validateSlideOffset,
      default: () => slideOffset
    }
  },
  data: () => ({}),
  computed: {},
  methods: {
    onEnter(element) {
      this.slideElement(element, "enter");
      element.offsetTop;
      this.setupTransition(element, "enter");
      element.style.removeProperty("opacity");
      element.style.removeProperty("transform");
    },
    onLeave(element) {
      this.setupTransition(element, "leave");
      this.slideElement(element, "leave");
    },
    slideElement(element, event = "enter") {
      var _a;
      const { width, height, transform } = getComputedStyle(element);
      const offset = ((_a = this.offset) == null ? void 0 : _a[event]) ?? this.offset;
      let [offsetX, offsetY] = offset;
      if (!isNumeric(offsetX)) {
        const val = offsetX.endsWith("%") ? parseFloat(width) * (parseFloat(offsetX.slice(0, -1)) || 0) / 100 : parseFloat(offsetX);
        offsetX = val;
      }
      if (!isNumeric(offsetY)) {
        const val = offsetY.endsWith("%") ? parseFloat(height) * (parseFloat(offsetY.slice(0, -1)) || 0) / 100 : parseFloat(offsetY);
        offsetY = val;
      }
      const [matrixType, matrix] = getMatrix(transform);
      if (transform.startsWith("matrix3d")) {
        matrix[12] += offsetX;
        matrix[13] += offsetY;
      } else if (transform.startsWith("matrix")) {
        matrix[4] += offsetX;
        matrix[5] += offsetY;
      } else {
        matrix[4] = offsetX;
        matrix[5] = offsetY;
      }
      if (!this.noOpacity) {
        element.style.setProperty("opacity", 0);
      }
      element.style.setProperty("transform", `${matrixType}(${matrix})`);
    },
    resetElement(element) {
      element.style.removeProperty("opacity");
      element.style.removeProperty("transform");
    }
  }
};
const __cssModules = {};
var __component__ = /* @__PURE__ */ normalizeComponent(
  __vue2_script,
  render,
  staticRenderFns,
  false,
  __vue2_injectStyles,
  null,
  null,
  null
);
function __vue2_injectStyles(context) {
  for (let o in __cssModules) {
    this[o] = __cssModules[o];
  }
}
const TransitionSlide = /* @__PURE__ */ function() {
  return __component__.exports;
}();
const components = { TransitionExpand, TransitionFade, TransitionScale, TransitionSlide };
const setProp = (component, prop, value) => {
  component.props ?? (component.props = {});
  component.props[prop] = {
    default: isArray(value) || isObject(value) ? () => value : value
  };
};
const getComponentDeclaration = (name, options) => {
  var _a;
  const defaultProps = (options == null ? void 0 : options.defaultProps) ?? {};
  const componentProps = ((_a = options == null ? void 0 : options.componentDefaultProps) == null ? void 0 : _a[name]) ?? {};
  Object.entries(defaultProps).forEach(([prop, propValue]) => {
    setProp(components[name], prop, propValue);
  });
  Object.entries(componentProps).forEach(([prop, propValue]) => {
    setProp(components[name], prop, propValue);
  });
  return components[name];
};
const install = function(Vue, options = {}) {
  Object.keys(components).forEach((name) => {
    Vue.component(name, getComponentDeclaration(name, options));
  });
};
const plugin = (pluginOptions) => ({
  install(Vue, options) {
    install(Vue, pluginOptions);
  }
});
const index = { install };
export {
  TransitionExpand,
  TransitionFade,
  TransitionScale,
  TransitionSlide,
  index as default,
  plugin
};
