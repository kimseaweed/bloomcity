"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  FORMAT_DATE_LOCALE_EN: () => FORMAT_DATE_LOCALE_EN,
  FORMAT_DATE_LOCALE_RU: () => FORMAT_DATE_LOCALE_RU,
  angle: () => angle,
  arrayInsert: () => arrayInsert,
  arrayInsertMutable: () => arrayInsertMutable,
  arrayOfLength: () => arrayOfLength,
  arrayRange: () => arrayRange,
  arrayRemove: () => arrayRemove,
  arrayRemoveMutable: () => arrayRemoveMutable,
  arraySample: () => arraySample,
  arrayShuffle: () => arrayShuffle,
  arraySwap: () => arraySwap,
  arraySwapMutable: () => arraySwapMutable,
  arrayUnique: () => arrayUnique,
  arraysDifference: () => arraysDifference,
  arraysIntersection: () => arraysIntersection,
  arraysUnion: () => arraysUnion,
  assert: () => assert,
  asyncArray: () => asyncArray,
  camelCase: () => camelCase,
  capitalize: () => capitalize,
  clamp: () => clamp,
  compose: () => compose,
  configureAssert: () => configureAssert,
  createFormatDate: () => createFormatDate,
  createMergeObjects: () => createMergeObjects,
  daysInMonth: () => daysInMonth,
  debounce: () => debounce,
  deepClone: () => deepClone,
  deepCloneStrict: () => deepCloneStrict,
  deepEqual: () => deepEqual,
  deepEqualCircular: () => deepEqualCircular,
  distance: () => distance,
  escapeRegExp: () => escapeRegExp,
  fileExtension: () => fileExtension,
  formDataToObject: () => formDataToObject,
  formatBytes: () => formatBytes,
  formatBytesRu: () => formatBytesRu,
  formatDate: () => formatDate,
  formatDateEn: () => formatDateEn,
  formatDateRu: () => formatDateRu,
  formatSlashes: () => formatSlashes,
  gcd: () => gcd,
  getDocumentSize: () => getDocumentSize,
  getElement: () => getElement,
  getElementOffset: () => getElementOffset,
  getScrollLimit: () => getScrollLimit,
  getScrollableAncestor: () => getScrollableAncestor,
  getScrollbarWidth: () => getScrollbarWidth,
  getWindowScroll: () => getWindowScroll,
  hash: () => hash,
  isArray: () => isArray,
  isBlob: () => isBlob,
  isBoolean: () => isBoolean,
  isClient: () => isClient,
  isDate: () => isDate,
  isDev: () => isDev,
  isElement: () => isElement,
  isEmail: () => isEmail,
  isEmpty: () => isEmpty,
  isError: () => isError,
  isFile: () => isFile,
  isFirefox: () => isFirefox,
  isFloat: () => isFloat,
  isFormData: () => isFormData,
  isFunction: () => isFunction,
  isHex: () => isHex,
  isInteger: () => isInteger,
  isInternetExplorer: () => isInternetExplorer,
  isIsoDate: () => isIsoDate,
  isIterable: () => isIterable,
  isLeapYear: () => isLeapYear,
  isLighthouse: () => isLighthouse,
  isLocalStorageAvailable: () => isLocalStorageAvailable,
  isMap: () => isMap,
  isMobile: () => isMobile,
  isMotionless: () => isMotionless,
  isNode: () => isNode,
  isNull: () => isNull,
  isNullish: () => isNullish,
  isNumeric: () => isNumeric,
  isOSX: () => isOSX,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  isPrimitive: () => isPrimitive,
  isProd: () => isProd,
  isPromise: () => isPromise,
  isRegExp: () => isRegExp,
  isServer: () => isServer,
  isSessionStorageAvailable: () => isSessionStorageAvailable,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isTest: () => isTest,
  isTouch: () => isTouch,
  isUndefined: () => isUndefined,
  isWeakMap: () => isWeakMap,
  kebabCase: () => kebabCase,
  lerp: () => lerp,
  mergeObjects: () => mergeObjects,
  minTimePromise: () => minTimePromise,
  noop: () => noop,
  numberFormat: () => numberFormat,
  objectGet: () => objectGet,
  objectKeysCase: () => objectKeysCase,
  objectToFormdata: () => objectToFormdata,
  omit: () => omit,
  padEnd: () => padEnd,
  padStart: () => padStart,
  parseDate: () => parseDate,
  parseResponseCookie: () => parseResponseCookie,
  pascalCase: () => pascalCase,
  pick: () => pick,
  precision: () => precision,
  promiseController: () => promiseController,
  queryStringify: () => queryStringify,
  quote: () => quote,
  randomDate: () => randomDate,
  randomFloat: () => randomFloat,
  randomInteger: () => randomInteger,
  randomString: () => randomString,
  rangeIncludes: () => rangeIncludes,
  rangesCrop: () => rangesCrop,
  rangesIntersection: () => rangesIntersection,
  rangesInvert: () => rangesInvert,
  rangesMerge: () => rangesMerge,
  rangesSort: () => rangesSort,
  romanize: () => romanize,
  safeJsonParse: () => safeJsonParse,
  serializeCookie: () => serializeCookie,
  sleep: () => sleep,
  snakeCase: () => snakeCase,
  stripIndent: () => stripIndent,
  supportsPassive: () => supportsPassive,
  throttle: () => throttle,
  toArray: () => toArray,
  toDate: () => toDate,
  toNumber: () => toNumber,
  tsObject: () => tsObject,
  unquote: () => unquote,
  verifyFileAccept: () => verifyFileAccept,
  withProbability: () => withProbability
});
module.exports = __toCommonJS(src_exports);

// src/arrays/array-insert/array-insert.ts
var arrayInsertMutable = (arr, index, ...items) => {
  arr.splice(index, 0, ...items);
  return arr;
};
var arrayInsert = (arr, index, ...items) => arrayInsertMutable([...arr], index, ...items);

// src/guards/is-array/is-array.ts
var isArray = (value) => Array.isArray(value);

// src/guards/is-blob/is-blob.ts
var isBlob = (value) => {
  if (typeof Blob === "undefined")
    return false;
  return value instanceof Blob || Object.prototype.toString.call(value).includes("Blob");
};

// src/guards/is-boolean/is-boolean.ts
var isBoolean = (value) => value === true || value === false;

// src/guards/is-date/is-date.ts
var isDate = (value, checkValidity) => {
  const isDateObject = Object.prototype.toString.call(value).includes("Date");
  if (!isDateObject)
    return false;
  if (!checkValidity)
    return isDateObject;
  return !Number.isNaN(value.getTime());
};

// src/guards/is-element/is-element.ts
var isElement = (value) => value instanceof Element;

// src/guards/is-string/is-string.ts
var isString = (value) => Object.prototype.toString.call(value) === "[object String]";

// src/guards/is-email/is-email.ts
var isEmail = (value) => isString(value) && /^(([^\s"(),.:;<>@[\\\]]+(\.[^\s"(),.:;<>@[\\\]]+)*)|(".+"))@((\[(?:\d{1,3}\.){3}\d{1,3}])|(([\d\-A-Za-zЁА-яё]+\.)+[A-Za-zЁА-яё]{2,}))$/.test(value);

// src/guards/is-iterable/is-iterable.ts
var isIterable = (value) => (
  // eslint-disable-next-line unicorn/new-for-builtins
  Symbol.iterator in Object(value)
);

// src/guards/is-object/is-object.ts
var isObject = (value) => Object.prototype.toString.call(value).includes("Object");

// src/guards/is-empty/is-empty.ts
var isEmpty = (value) => {
  if (value === void 0)
    return true;
  if (value === null)
    return true;
  if (value === false)
    return true;
  if (Number.isNaN(value))
    return true;
  if (value === 0)
    return true;
  if (value === BigInt(0))
    return true;
  if (value === "")
    return true;
  if (isIterable(value) && typeof value === "object" && "length" in value && value.length === 0)
    return true;
  if (isIterable(value) && typeof value === "object" && "size" in value && value.size === 0)
    return true;
  if (isObject(value))
    return !Object.keys(value).length;
  return false;
};

// src/guards/is-error/is-error.ts
var isError = (value) => value instanceof Error;

// src/guards/is-file/is-file.ts
var isFile = (value) => {
  if (typeof File === "undefined")
    return false;
  return value instanceof File || Object.prototype.toString.call(value).includes("File");
};

// src/guards/is-numeric/is-numeric.ts
var isNumeric = (value) => typeof value === "number" && !isNaN(value);

// src/guards/is-float/is-float.ts
var isFloat = (value) => isNumeric(value) && value % 1 !== 0;

// src/guards/is-form-data/is-form-data.ts
var isFormData = (value) => value instanceof FormData;

// src/guards/is-function/is-function.ts
var isFunction = (value) => Object.prototype.toString.call(value) === "[object Function]";

// src/guards/is-hex/is-hex.ts
var isHex = (value) => {
  if (!isString(value))
    return false;
  return /^#(?:[\da-f]{8}|[\da-f]{6}|[\da-f]{4}|[\da-f]{3})$/i.test(value.toLowerCase());
};

// src/guards/is-integer/is-integer.ts
var isInteger = (value) => Number.isInteger(value);

// src/guards/is-local-storage-available/is-local-storage-available.ts
var TEST_KEY = "__TEST_KEY__";
var isLocalStorageAvailable = () => {
  if (typeof localStorage === "undefined")
    return false;
  try {
    localStorage.setItem(TEST_KEY, "value");
    localStorage.removeItem(TEST_KEY);
    return true;
  } catch {
    return false;
  }
};

// src/guards/is-map/is-map.ts
var isMap = (value) => value instanceof Map;

// src/guards/is-node/is-node.ts
var isNode = (value) => value instanceof Node;

// src/guards/is-null/is-null.ts
var isNull = (value) => value === null;

// src/guards/is-undefined/is-undefined.ts
var isUndefined = (value) => value === void 0;

// src/guards/is-nullish/is-nullish.ts
var isNullish = (value) => isNull(value) || isUndefined(value);

// src/guards/is-plain-object/is-plain-object.ts
var isPlainObject = (value) => {
  if (!isObject(value))
    return false;
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
};

// src/guards/is-primitive/is-primitive.ts
var isPrimitive = (value) => {
  if (isNullish(value))
    return true;
  return !["object", "function"].includes(typeof value);
};

// src/guards/is-promise/is-promise.ts
var isPromise = (value) => value instanceof Promise;

// src/guards/is-reg-exp/is-reg-exp.ts
var isRegExp = (value) => Object.prototype.toString.call(value) === "[object RegExp]";

// src/guards/is-session-storage-available/is-session-storage-available.ts
var TEST_KEY2 = "__TEST_KEY__";
var isSessionStorageAvailable = () => {
  if (typeof sessionStorage === "undefined")
    return false;
  try {
    sessionStorage.setItem(TEST_KEY2, "value");
    sessionStorage.removeItem(TEST_KEY2);
    return true;
  } catch {
    return false;
  }
};

// src/guards/is-symbol/is-symbol.ts
var isSymbol = (value) => typeof value === "symbol" || typeof value === "object" && Object.prototype.toString.call(value).includes("Symbol");

// src/guards/is-weak-map/is-weak-map.ts
var isWeakMap = (value) => value instanceof WeakMap;

// src/arrays/array-of-length/array-of-length.ts
var arrayOfLength = (length, mapFunction) => {
  const neededLength = isInteger(length) && length > 0 ? length : 0;
  const arr = new Array(neededLength).fill(void 0);
  return mapFunction ? arr.map((_, index) => mapFunction(index)) : arr;
};

// src/arrays/array-range/array-range.ts
var arrayRange = (from, to) => {
  if (to === void 0) {
    if (from < 0) {
      to = 0;
    } else {
      to = from;
      from = 0;
    }
  }
  return arrayOfLength(Math.abs(to - from) + 1, (index) => index).map((i) => (from > to ? -i : i) + from);
};

// src/arrays/array-remove/array-remove.ts
var arrayRemoveMutable = (arr, value, onlyFirst = false) => {
  while (true) {
    const occurrence = arr.indexOf(value);
    if (occurrence === -1)
      return arr;
    arr.splice(occurrence, 1);
    if (onlyFirst)
      return arr;
  }
};
var arrayRemove = (arr, value, onlyFirst = false) => arrayRemoveMutable([...arr], value, onlyFirst);

// src/numbers/random-integer/random-integer.ts
var randomInteger = (min = 1, max = Number.MAX_SAFE_INTEGER) => Math.floor(Math.random() * (max - min + 1)) + min;

// src/arrays/array-shuffle/array-shuffle.ts
var arrayShuffle = (array) => {
  const copy2 = [...array];
  for (let i = copy2.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [copy2[i], copy2[j]] = [copy2[j], copy2[i]];
  }
  return copy2;
};

// src/arrays/array-sample/array-sample.ts
var arraySample = (array, size = 1, oversize = false) => {
  if (!array?.length || !isInteger(size) || size < 1)
    return void 0;
  if (size === 1) {
    return array[randomInteger(0, array.length - 1)];
  }
  !oversize && (size = Math.min(array.length, size));
  const result = [];
  while (result.length < size) {
    const neededCount = size - result.length;
    const iterationIndexes = arrayOfLength(array.length, (index) => index);
    if (neededCount > array.length) {
      result.push(...iterationIndexes.map((i) => array[i]));
    } else {
      result.push(...arrayShuffle(iterationIndexes).slice(0, neededCount).map((i) => array[i]));
    }
  }
  return result;
};

// src/numbers/clamp/clamp.ts
var clamp = (value, min = -Infinity, max = Infinity) => Math.max(
  min ?? -Infinity,
  Math.min(value, max ?? Infinity)
);

// src/functions/assert/assert.utils.ts
var typeMap = {
  "condition": "Assert condition failed",
  "no-value": "Assert value not undefined/null failed"
};
var messageFormatter = (failureType, message, properties) => {
  return [
    typeMap[failureType],
    message ? `: ${message}` : null,
    !isEmpty(properties) ? `: ${JSON.stringify(properties)}` : null
  ].filter(Boolean).join("");
};
var errorCreatorFactory = (formatter) => (failureType, message, properties) => new Error(formatter(failureType, message, properties));
var createConfiguration = () => ({
  formatter: messageFormatter,
  errorCreator: errorCreatorFactory(messageFormatter)
});

// src/functions/assert/assert.ts
var configuration = createConfiguration();
var _createAssert = (soft) => (conditionOrValue, message, properties) => {
  const createError = (type, props2) => configuration.errorCreator(type, message, props2);
  const report = (type, props2, error) => {
    error && configuration.errorReporter?.(type, error, message, props2);
    !error && configuration.warningReporter?.(type, message, props2);
  };
  const props = isFunction(properties) ? properties() : properties ?? {};
  if (isBoolean(conditionOrValue) && !conditionOrValue) {
    if (!soft) {
      const error = createError("condition", props);
      report("condition", props, error);
      throw error;
    }
    report("condition", props);
    return false;
  }
  if (isNullish(conditionOrValue)) {
    if (!soft) {
      const error = createError("no-value", props);
      report("no-value", props, error);
      throw error;
    }
    report("no-value", props);
    return false;
  }
  return conditionOrValue;
};
var hardAssert = _createAssert(false);
var softAssert = _createAssert(true);
var _assert = hardAssert;
_assert.soft = softAssert;
var assert = _assert;
var configureAssert = (customConfiguration) => {
  configuration = {
    ...configuration,
    ...customConfiguration,
    errorCreator: customConfiguration.errorCreator ?? errorCreatorFactory(customConfiguration.formatter ?? messageFormatter)
  };
};

// src/ranges/ranges.utils.ts
var formatInfinity = (value, isNeeded) => {
  if (!isNeeded)
    return isNullish(value) ? null : value;
  return value === Infinity || value === -Infinity ? null : isNullish(value) ? null : value;
};

// src/ranges/ranges-sort/ranges-sort.ts
var comparator = (a, b) => {
  if (isNullish(a) && isNullish(b))
    return 0;
  if (isNullish(a) && !isNullish(b))
    return -1;
  if (!isNullish(a) && isNullish(b))
    return 1;
  assert(isNumeric(a) && isNumeric(b));
  if (a < b)
    return -1;
  if (a > b)
    return 1;
  return 0;
};
var rangesSort = (ranges, infinityToNull = false) => {
  return [...ranges ?? []].filter((r) => !isNullish(r)).sort((r1, r2) => {
    assert(!isNullish(r1) && !isNullish(r2));
    if (r1[0] === r2[0]) {
      return comparator(r1[1], r2[1]);
    }
    return comparator(r1[0], r2[0]);
  }).map((range) => [
    formatInfinity(range[0], infinityToNull),
    formatInfinity(range[1], infinityToNull)
  ]);
};

// src/ranges/ranges-merge/ranges-merge.ts
var rangesMerge = (ranges, joinEdges = true, infinityToNull = false) => {
  const sorted = rangesSort(ranges, infinityToNull).map((r) => [
    isNullish(r[0]) ? -Infinity : r[0],
    isNullish(r[1]) ? Infinity : r[1]
  ]);
  for (let l = sorted.length - 1, i = l; i > 0; i--) {
    if (sorted[i][0] <= sorted[i - 1][0] || !joinEdges && sorted[i][0] < sorted[i - 1][1] || joinEdges && sorted[i][0] <= sorted[i - 1][1]) {
      sorted[i - 1][0] = Math.min(sorted[i][0], sorted[i - 1][0]);
      sorted[i - 1][1] = Math.max(sorted[i][1], sorted[i - 1][1]);
      sorted.splice(i, 1);
      i = sorted.length;
    }
  }
  return sorted.length ? sorted.map((r) => [
    formatInfinity(r[0], infinityToNull),
    formatInfinity(r[1], infinityToNull)
  ]) : [];
};

// src/ranges/ranges-intersection/ranges-intersection.ts
var DEFAULT_OPTIONS = {
  inclusive: false
};
var safeNumber = (maybeNumber, sign = "+") => maybeNumber ?? (sign === "+" ? Infinity : -Infinity);
var rangesIntersection = (ranges, userOptions) => {
  if (!ranges)
    return [];
  const options = { ...DEFAULT_OPTIONS, ...userOptions };
  const isOverlapping = (minRange, maxRange) => {
    return options.inclusive ? safeNumber(minRange[1]) >= safeNumber(maxRange[0], "-") : safeNumber(minRange[1]) > safeNumber(maxRange[0], "-");
  };
  const matches = ranges.filter(Boolean).reduce(
    (acc, r1, index) => {
      if (index === ranges.length - 1)
        return acc;
      const restRanges = ranges.slice(index + 1).filter(Boolean);
      restRanges.forEach((r2) => {
        const min = safeNumber(r1[0], "-") < safeNumber(r2[0], "-") ? r1 : r2;
        const max = min === r1 ? r2 : r1;
        if (!isOverlapping(min, max))
          return null;
        acc.push([
          safeNumber(max[0], "-"),
          safeNumber(min[1]) < safeNumber(max[1]) ? safeNumber(min[1]) : safeNumber(max[1])
        ]);
      });
      return acc;
    },
    []
  );
  return rangesMerge(matches, options.inclusive);
};

// src/arrays/to-array/to-array.ts
var toArray = (value) => [value].flat();

// src/arrays/array-swap/array-swap.ts
var arraySwapMutable = (arr, firstPosition, secondPosition) => {
  const isInRange = (index) => index >= 0 && index <= arr.length - 1;
  const [first, second] = [firstPosition, secondPosition].map((position) => toArray(position)).sort((a, b) => a[0] > b[0] ? 1 : -1);
  if (first.some((position) => !isInRange(position))) {
    throw new Error("First swap position outside the array range");
  }
  if (!isUndefined(first[1]) && first[1] < first[0]) {
    throw new Error("The end edge of the first position is lower than the start edge");
  }
  if (second.some((position) => !isInRange(position))) {
    throw new Error("Second swap position outside the array range");
  }
  if (!isUndefined(second[1]) && second[1] < second[0]) {
    throw new Error("The end edge of the second position is lower than the start edge");
  }
  if (first.length === 1 && second.length === 1) {
    [arr[first[0]], arr[second[0]]] = [arr[second[0]], arr[first[0]]];
    return arr;
  }
  const [firstRange, secondRange] = [first, second].map((values) => values.length === 1 ? [values[0], values[0]] : values);
  if (rangesIntersection([firstRange, secondRange], { inclusive: true }).length) {
    throw new Error("The edges cannot be crossed");
  }
  const firstSlice = arr.splice(first[0], first[1] ? first[1] - first[0] + 1 : 1);
  const secondSlice = arr.splice(
    clamp(second[0] - firstSlice.length, 0),
    second[1] ? second[1] - second[0] + 1 : 1
  );
  arr.splice(first[0], 0, ...secondSlice);
  arr.splice(second[0] + secondSlice.length - firstSlice.length, 0, ...firstSlice);
  return arr;
};
var arraySwap = (arr, firstPosition, secondPosition) => {
  return arraySwapMutable([...arr], firstPosition, secondPosition);
};

// src/arrays/array-unique/array-unique.ts
var arrayUnique = (array) => [...new Set(array)];

// src/arrays/arrays-intersection/arrays-intersection.ts
var arraysIntersection = (...arrays) => arrays.reduce((acc, array) => acc.filter((i) => array.includes(i)));

// src/arrays/arrays-union/arrays-union.ts
var arraysUnion = (...arrays) => [...new Set(arrays.flat())];

// src/arrays/arrays-difference/arrays-difference.ts
var arraysDifference = (...arrays) => {
  const intersections = arraysIntersection(...arrays);
  return arraysUnion(...arrays.map((array) => array.filter((i) => !intersections.includes(i))));
};

// src/arrays/async-array/async-array.utils.ts
var resolve = async (collectionOrPromise) => {
  if (isArray(collectionOrPromise))
    return Promise.all(collectionOrPromise);
  return Promise.all([collectionOrPromise]);
};
var series = (reducer, initial, order = "left-to-right") => {
  const method = order === "left-to-right" ? "reduce" : "reduceRight";
  return (iterable) => {
    return iterable[method]((accumulator, value, index) => {
      return accumulator.then((results) => reducer(results, value, index, iterable));
    }, Promise.resolve(initial));
  };
};

// src/arrays/async-array/async-array.ts
function forEach(callback) {
  return resolve(this).then(
    series((results, value, index, arr) => callback(value, index, arr), void 0)
  );
}
function reduce(reducer, initial) {
  return resolve(this).then(
    series(reducer, initial, "left-to-right")
  );
}
function reduceRight(reducer, initial) {
  return resolve(this).then(
    series(reducer, initial, "right-to-left")
  );
}
function map(mapper) {
  return resolve(this).then(
    (values) => Promise.all(
      values.map((value, index, arr) => mapper(value, index, arr))
    )
  );
}
var asyncArray = (arr) => {
  return {
    forEach: forEach.bind(arr),
    reduce: reduce.bind(arr),
    reduceRight: reduceRight.bind(arr),
    map: map.bind(arr)
  };
};

// src/strings/camel-case/camel-case.ts
var UPPERCASE = /\p{Lu}/u;
var LOWERCASE = /\p{Ll}/u;
var LEADING_CAPITAL = /^\p{Lu}(?!\p{Lu})/gu;
var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
var SEPARATORS = /[ \-._]+/;
var LEADING_SEPARATORS = new RegExp(`^${SEPARATORS.source}`);
var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
var NUMBERS_AND_IDENTIFIER = new RegExp(`\\d+${IDENTIFIER.source}`, "gu");
var defaultOptions = {
  preserveConsecutiveUppercase: false
};
var preserveCamelCase = (string) => {
  let isLastCharLower = false;
  let isLastCharUpper = false;
  let isLastLastCharUpper = false;
  for (let i = 0; i < string.length; i++) {
    const character = string[i];
    if (isLastCharLower && UPPERCASE.test(character)) {
      string = `${string.slice(0, i)}-${string.slice(i)}`;
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      i++;
    } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
      string = `${string.slice(0, i - 1)}-${string.slice(i - 1)}`;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
    }
  }
  return string;
};
var preserveConsecutiveUppercase = (input) => {
  LEADING_CAPITAL.lastIndex = 0;
  return input.replaceAll(LEADING_CAPITAL, (m1) => m1.toLowerCase());
};
var postProcess = (input) => {
  SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
  NUMBERS_AND_IDENTIFIER.lastIndex = 0;
  return input.replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier) => identifier.toUpperCase()).replaceAll(NUMBERS_AND_IDENTIFIER, (m) => m.toUpperCase());
};
var camelCase = (input, options) => {
  if (!isArray(!input) && !isString(input)) {
    throw new TypeError("Expected the input to be `string | string[]`");
  }
  options = { ...defaultOptions, ...options };
  input = isArray(input) ? input.map((v) => v.trim()).filter(Boolean).join("-") : input.trim();
  if (!input.length)
    return "";
  if (input.length === 1)
    return input.toLowerCase();
  if (input !== input.toLowerCase()) {
    input = preserveCamelCase(input);
  }
  input = input.replace(LEADING_SEPARATORS, "");
  input = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input) : input.toLowerCase();
  return postProcess(input);
};

// src/strings/capitalize/capitalize.ts
var capitalize = (input) => {
  if (!input.length)
    return "";
  return input[0].toUpperCase() + input.slice(1);
};

// src/strings/escape-reg-exp/escape-reg-exp.ts
var escapeRegExp = (str) => (str ?? "").replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&");

// src/strings/file-extension/file-extension.ts
var fileExtension = (input) => {
  const basePath = input.split(/[/\\]/).pop();
  return basePath.slice((Math.max(0, basePath.lastIndexOf(".")) || Infinity) + 1) || null;
};

// src/strings/format-slashes/format-slashes.ts
var formatSlashes = (input, options) => {
  input = input.replaceAll(/([^:]\/)\/+/g, "$1").replaceAll(/\\{2,}/g, "\\");
  if (options?.to) {
    const re = options.to === "/" ? "\\\\" : "/";
    input = input.replaceAll(new RegExp(re, "g"), options.to);
  }
  const slash = options?.to ?? input.match(/[/\\]/)?.[0] ?? "/";
  if (options?.start === true && !input.startsWith(slash)) {
    input = slash + input;
  }
  if (options?.start === false && input.startsWith(slash)) {
    input = input.slice(1);
  }
  if (options?.end === true && !input.endsWith(slash)) {
    input += slash;
  }
  if (options?.end === false && input.endsWith(slash)) {
    input = input.slice(0, -1);
  }
  return input;
};

// src/strings/kebab-case/kebab-case.ts
var kebabCase = (input, _options2) => {
  const options = { numbers: false, ..._options2 };
  let result = input.replaceAll(/([a-z])([A-Z])/g, "$1-$2").replaceAll(/[\s._]+/g, "-");
  if (!options.numbers)
    return result.toLowerCase();
  result = result.replace(/\d+/, "-$&").replaceAll(/(\d)([A-Z])/g, "$1-$2");
  return result.startsWith("-") ? result.slice(1).toLowerCase() : result.toLowerCase();
};

// src/strings/pad-end/pad-end.ts
var padEnd = (input, maxLength, fillString = " ") => input.toString().padEnd(maxLength, fillString);

// src/strings/pad-start/pad-start.ts
var padStart = (input, maxLength = 2, fillString = "0") => input.toString().padStart(maxLength, fillString);

// src/strings/pascal-case/pascal-case.ts
var defaultOptions2 = {
  preserveConsecutiveUppercase: false
};
var pascalCase = (input, options) => {
  const base = camelCase(input, { ...defaultOptions2, ...options });
  if (!base.length)
    return "";
  return base[0].toUpperCase() + base.slice(1);
};

// src/strings/quote/quote.ts
var quote = (str, char = '"') => {
  if (str === "")
    return `${char}${char}`;
  const [first, last] = [str[0], str.at(-1)];
  if (first !== char)
    str = char + str;
  if (last !== char)
    str += char;
  return str;
};

// src/strings/random-string/random-string.ts
var randomString = (length = 10, startWithLatin = true) => {
  const base = arrayOfLength(length, () => Math.trunc(Math.random() * 36).toString(36)).join("");
  if (!startWithLatin)
    return base;
  const latinCharacters = "abcdefghijklmnopqrstuvwxyz";
  const firstChar = latinCharacters.charAt(Math.floor(Math.random() * latinCharacters.length));
  return firstChar + base.slice(1);
};

// src/strings/romanize/romanize.ts
var numerals = {
  M: 1e3,
  CM: 900,
  D: 500,
  CD: 400,
  C: 100,
  XC: 90,
  L: 50,
  XL: 40,
  X: 10,
  IX: 9,
  V: 5,
  IV: 4,
  I: 1
};
var romanize = (num) => Object.entries(numerals).reduce((acc, [key, value]) => {
  acc += key.repeat(num / value >>> 0);
  num %= value;
  return acc;
}, "");

// src/strings/snake-case/snake-case.ts
var snakeCase = (input) => input.replaceAll(/([a-z])([A-Z])/g, "$1-$2").replaceAll(/[\s\-.]+/g, "_").toLowerCase();

// src/strings/strip-indent/strip-indent.ts
var _getMinimalIndent = (input) => {
  const match = input.match(/^[\t ]*(?=\S)/gm);
  if (!match)
    return 0;
  return match.reduce((minimalIndentation, spacings) => Math.min(minimalIndentation, spacings.length), Infinity);
};
var DEFAULTS = {
  trimLeadingSpacings: true,
  trimTrailingSpacings: true
};
var _applyOptions = (input, options) => {
  options.trimLeadingSpacings && (input = input.replace(/^\n\s*(?=\S)/, ""));
  options.trimTrailingSpacings && (input = input.replace(/\n\s*$/, ""));
  return input;
};
var stripIndent = (input, userOptions) => {
  const options = { ...DEFAULTS, ...userOptions };
  const minIndent = _getMinimalIndent(input);
  if (minIndent === 0)
    return _applyOptions(input, options);
  const regex = new RegExp(`^[	 ]{${minIndent}}`, "gm");
  return _applyOptions(input, options).replace(regex, "");
};

// src/strings/unquote/unquote.ts
var unquote = (str) => {
  if (!str)
    return "";
  const [first, last] = [str[0], str.at(-1)];
  if (first !== last)
    return str;
  if (first === '"' || first === "'" || first === "`")
    return str.slice(1, -1);
  return str;
};

// src/cookies/parse-response-cookie/parse-response-cookie.utils.ts
var parseNameValuePair = (maybePair) => {
  const parts = maybePair.split("=");
  if (parts.length === 1) {
    return { name: "", value: maybePair };
  }
  if (parts.length > 1) {
    const [name, ...values] = parts;
    return { name, value: values.join("=") };
  }
  return null;
};
var DEFAULT_OPTIONS2 = {
  decodeValues: true,
  returnType: "array"
};
var parseCookieChunk = (chunk, decodeValues) => {
  const parts = chunk.split(";").filter(Boolean);
  const pair = parts.shift();
  if (!pair)
    return null;
  const parsed = parseNameValuePair(pair);
  if (!parsed)
    return null;
  const value = (() => {
    if (!decodeValues)
      return parsed.value;
    try {
      return decodeURIComponent(parsed.value);
    } catch {
      return parsed.value;
    }
  })();
  const cookie = {
    name: parsed.name,
    value
  };
  parts.forEach((part) => {
    const sides = part.split("=");
    if (isEmpty(sides))
      return;
    const key = sides.shift().trim().toLowerCase();
    const keyValue = sides.join("=");
    if (key === "expires") {
      const maybeDate = new Date(keyValue);
      if (!isDate(maybeDate, true))
        return;
      cookie.expires = new Date(keyValue);
      return;
    }
    if (key === "max-age") {
      const maybeNumber = parseInt(keyValue, 10);
      if (Number.isNaN(maybeNumber))
        return;
      cookie.maxAge = maybeNumber;
      return;
    }
    if (key === "secure") {
      cookie.secure = true;
      return;
    }
    if (key === "httponly") {
      cookie.httpOnly = true;
      return;
    }
    if (key === "samesite") {
      if (keyValue.toLowerCase() === "strict" || keyValue.toLowerCase() === "lax" || keyValue.toLowerCase() === "none") {
        cookie.sameSite = capitalize(keyValue.toLowerCase());
      }
      return;
    }
    if (key === "partitioned") {
      cookie.partitioned = true;
      return;
    }
    if (key === "priority") {
      if (keyValue.toLowerCase() === "low" || keyValue.toLowerCase() === "medium" || keyValue.toLowerCase() === "high") {
        cookie.priority = capitalize(keyValue.toLowerCase());
      }
      return;
    }
    keyValue && (cookie[key] = keyValue);
  });
  return cookie;
};
var splitCookiesString = (cookiesString) => {
  if (isArray(cookiesString))
    return cookiesString;
  if (!isString(cookiesString))
    return [];
  const cookieStrings = [];
  let position = 0;
  const skipWhitespace = () => {
    while (position < cookiesString.length && /\s/.test(cookiesString[position])) {
      position++;
    }
    return position < cookiesString.length;
  };
  const notSpecialCharacter = () => {
    return !["=", ";", ","].includes(cookiesString[position]);
  };
  while (position < cookiesString.length) {
    let start = position;
    let cookiesSeparatorFound = false;
    let lastComma = 0;
    let nextStart = 0;
    while (skipWhitespace()) {
      if (cookiesString[position] !== ",") {
        position++;
        continue;
      }
      lastComma = position++;
      skipWhitespace();
      nextStart = position;
      while (notSpecialCharacter() && position < cookiesString.length) {
        position++;
      }
      if (position < cookiesString.length && cookiesString[position] === "=") {
        cookiesSeparatorFound = true;
        position = nextStart;
        cookieStrings.push(cookiesString.slice(start, lastComma));
        start = position;
      } else {
        position = lastComma + 1;
      }
    }
    if (!cookiesSeparatorFound || position >= cookiesString.length) {
      cookieStrings.push(cookiesString.slice(start, cookiesString.length));
    }
  }
  return cookieStrings;
};

// src/cookies/parse-response-cookie/parse-response-cookie.ts
var parseResponseCookie = (input, userOptions) => {
  const options = { ...DEFAULT_OPTIONS2, ...userOptions };
  if (isEmpty(input)) {
    return options.returnType === "array" ? [] : {};
  }
  const setCookieValue = toArray((() => {
    if (isString(input))
      return splitCookiesString(input);
    if (isArray(input))
      return input.reduce((acc, value) => [...acc, ...splitCookiesString(value)], []);
    if (isObject(input) && "headers" in input) {
      if (isFunction(input.headers.getSetCookie))
        return splitCookiesString(input.headers.getSetCookie());
      if ("set-headers" in input.headers) {
        return splitCookiesString(input.headers["set-cookie"]) ?? "";
      }
      const key = Object.keys(input.headers).find((header) => header.toLowerCase() === "set-cookie");
      if (key && key in input.headers) {
        return splitCookiesString(input.headers[key]);
      }
      return "";
    }
    return "";
  })()).filter(Boolean);
  return options.returnType === "array" ? setCookieValue.map((chunk) => {
    return parseCookieChunk(chunk, options.decodeValues);
  }).filter(Boolean) : setCookieValue.reduce((acc, chunk) => {
    const cookie = parseCookieChunk(chunk, options.decodeValues);
    if (!cookie)
      return acc;
    acc[cookie.name] = cookie;
    return acc;
  }, {});
};

// src/cookies/serialize-cookie/serialize-cookie.ts
var DEFAULT_OPTIONS3 = {
  encodeValue: true
};
var serializeCookie = (cookie, userOptions) => {
  const options = { ...DEFAULT_OPTIONS3, ...userOptions };
  const value = options.encodeValue ? encodeURIComponent(cookie.value) : cookie.value;
  let cookieString = cookie.name ? `${cookie.name}=${value}` : value;
  if ("maxAge" in cookie && !isNullish(cookie.maxAge)) {
    const maybeMaxAge = parseInt(`${cookie.maxAge}`, 10);
    if (!Number.isNaN(maybeMaxAge) && Number.isFinite(maybeMaxAge)) {
      cookieString += `; Max-Age=${maybeMaxAge}`;
    }
  }
  if ("domain" in cookie && !isEmpty(cookie.domain)) {
    cookieString += `; Domain=${cookie.domain}`;
  }
  if ("path" in cookie && !isEmpty(cookie.path)) {
    cookieString += `; Path=${cookie.path}`;
  }
  if ("expires" in cookie && isDate(cookie.expires, true)) {
    cookieString += `; Expires=${cookie.expires.toUTCString()}`;
  }
  if (cookie.httpOnly) {
    cookieString += "; HttpOnly";
  }
  if (cookie.secure) {
    cookieString += "; Secure";
  }
  if (cookie.partitioned) {
    cookieString += "; Partitioned";
  }
  if (cookie.sameSite) {
    if (cookie.sameSite === "Strict" || cookie.sameSite === "Lax" || cookie.sameSite === "None") {
      cookieString += `; SameSite=${cookie.sameSite}`;
    }
  }
  if (cookie.priority) {
    if (cookie.priority === "Low" || cookie.priority === "Medium" || cookie.priority === "High") {
      cookieString += `; Priority=${cookie.priority}`;
    }
  }
  return cookieString;
};

// src/dates/days-in-month/days-in-month.ts
var daysInMonth = (monthIndex, year) => {
  year ??= (/* @__PURE__ */ new Date()).getFullYear();
  return new Date(year, monthIndex + 1, 0).getDate();
};

// src/objects/deep-clone/deep-clone.ts
var import_fast_copy = require("fast-copy");
var copy = (0, import_fast_copy.createCopier)({});
var deepClone = (value) => copy(value);
var deepCloneStrict = (value) => (0, import_fast_copy.copyStrict)(value);

// src/objects/deep-equal/deep-equal.ts
var import_fast_equals = require("fast-equals");
var deepEqual = (a, b) => (0, import_fast_equals.deepEqual)(a, b);
var deepEqualCircular = (a, b) => (0, import_fast_equals.circularDeepEqual)(a, b);

// src/objects/form-data-to-object/form-data-to-object.ts
var formDataToObject = (formData) => {
  if (!isFormData(formData))
    return formData;
  const result = {};
  for (const [key, value] of formData.entries()) {
    result[key] = key in result ? [...toArray(result[key]), value] : value;
  }
  return result;
};

// src/objects/merge-objects/merge-objects.ts
var _mergeObjects = (defaults, input, stack = "", merger) => {
  const result = { ...defaults };
  if (!isObject(input))
    return result;
  Object.entries(input).forEach(([key, val]) => {
    if (merger?.(result, key, val, stack))
      return;
    if (isObject(val) && isObject(result[key])) {
      Object.assign(result, { [key]: _mergeObjects(result[key], val, (stack ? `${stack}.` : "") + key, merger) });
    } else {
      Object.assign(result, { [key]: val });
    }
  });
  return result;
};
var createMergeObjects = (merger) => (...args) => args.reduce((p, c) => _mergeObjects(p, c, "", merger), {});
var mergeObjects = createMergeObjects();

// src/numbers/to-number/to-number.ts
function toNumber(value, fallback) {
  const throwOrReturnFallback = () => {
    if (arguments.length === 1) {
      throw new Error(`The value "${value}" cannot be converted to a number`);
    }
    return fallback;
  };
  if (isNumeric(value))
    return value;
  if (isString(value)) {
    const number = Number(value);
    return isNumeric(number) ? number : throwOrReturnFallback();
  }
  return throwOrReturnFallback();
}

// src/objects/object-get/object-get.ts
var extractSegments = (path) => toArray(path).map((p) => p.toString().trim()).flatMap((part) => part.replaceAll(/\[(.?)]/g, ".$1.").replaceAll(/\.+/g, ".").split(".").filter(Boolean).map((p) => toNumber(p, p)));
var objectGet = (input, path, defaultValue = void 0) => {
  if (!input || !isObject(input) && !isArray(input) || isNullish(path)) {
    return defaultValue;
  }
  const segments = extractSegments(path);
  let result = input;
  while (segments.length) {
    const property = segments.shift();
    if (!(property in result))
      return defaultValue;
    result = result[property];
  }
  return result;
};

// src/objects/object-keys-case/object-keys-case.ts
var getPath = (path, ...parts) => path ? `${path}.${parts.join(".")}` : parts.join(".");
var getHandler = (neededCase) => {
  switch (neededCase) {
    case "snake_case":
      return snakeCase;
    case "PascalCase":
      return pascalCase;
    case "camelCase":
      return camelCase;
    case "kebab-case":
      return kebabCase;
    default:
      return (v) => v;
  }
};
var objectKeysCase = (input, neededCase, _options2) => {
  const options = {
    depth: Infinity,
    exclude: [],
    excludeBranches: [],
    ..._options2
  };
  const handler = getHandler(neededCase);
  const isExcluded = (type, key) => {
    const entity = type === "key" ? options.exclude : options.excludeBranches;
    return entity.some((item) => {
      if (isString(item))
        return item === key;
      if (isRegExp(item))
        return item.test(key);
      return false;
    });
  };
  const isDepthAllowed = (depth) => options.depth > depth;
  const processEntry = (entry, path, depth) => {
    if (!isObject(entry) && !isArray(entry))
      return entry;
    const isEntryArray = isArray(entry);
    return Object.entries(entry).reduce((acc, [_key, _value]) => {
      const shouldTransformKey = !isExcluded("key", _key) && !isExcluded("branch", getPath(path, _key)) && isDepthAllowed(depth);
      const shouldTransformValue = !isExcluded("branch", getPath(path, _key)) && isDepthAllowed(depth + 1);
      const key = shouldTransformKey ? handler(_key) : _key;
      const value = shouldTransformValue ? processEntry(_value, getPath(path, _key), depth + 1) : _value;
      if (isEntryArray)
        acc.push(value);
      if (!isEntryArray)
        acc[key] = value;
      return acc;
    }, isEntryArray ? [] : {});
  };
  return processEntry(input, "", 0);
};

// src/objects/ts-object/ts-object.ts
var tsObject = {
  /**
   * Typed version of `Object.keys()`.
   *
   * @param   obj   Object to process.
   *
   * @returns       `Object.keys()` return value for a given object.
   */
  keys: (obj) => Object.keys(obj),
  /**
   * Typed version of `Object.values()`.
   *
   * @param   obj   Object to process.
   *
   * @returns       `Object.values()` return value for a given object.
   */
  values: (obj) => Object.values(obj),
  /**
   * Typed version of `Object.entries()`.
   *
   * @param   obj   Object to process.
   *
   * @returns       `Object.entries()` return value for a given object.
   */
  entries: (obj) => Object.entries(obj),
  /**
   * Typed version of `Object.fromEntries()`.
   *
   * @param   entries   Entries to process.
   *
   * @returns           `Object.fromEntries()` return value for a given object.
   */
  fromEntries: (entries) => Object.fromEntries(entries)
};

// src/objects/object-to-formdata/object-to-formdata.ts
var DEFAULT_OPTIONS4 = {
  indices: false,
  nullValues: "omit",
  booleanValues: "preserve-as-strings",
  emptyArrays: "omit",
  arrayBrackets: "append",
  objectKeysNotation: "brackets"
};
var serialize = (key, value, options, formData) => {
  if (isUndefined(value))
    return;
  if (isNull(value)) {
    if (options.nullValues === "omit")
      return;
    const realValue = options.nullValues === "preserve-as-empty-string" ? "" : "null";
    formData.append(key, realValue);
    return;
  }
  if (isDate(value)) {
    formData.append(key, value.toISOString());
    return;
  }
  if (isBoolean(value)) {
    const realValue = options.booleanValues === "preserve-as-integers" ? value ? "1" : "0" : value.toString();
    formData.append(key, realValue);
    return;
  }
  if (isArray(value)) {
    if (!value.length) {
      if (options.emptyArrays === "preserve") {
        formData.append(key, "");
      }
      return;
    }
    const isFilesArray = value.every((innerValue) => isFile(innerValue));
    value.forEach((arrayValue, index) => {
      const arrayKey = (() => {
        if (options.arrayBrackets === "append" || options.arrayBrackets === "append-only-for-files" && isFilesArray)
          return `${key}[${options.indices ? index : ""}]`;
        return key.replaceAll(/\[]$/gm, "");
      })();
      serialize(arrayKey, arrayValue, options, formData);
    });
    return;
  }
  if (isBlob(value)) {
    formData.append(key, value);
    return;
  }
  if (isObject(value)) {
    tsObject.entries(value).forEach(([innerKey, innerValue]) => {
      const realInnerKey = (() => {
        if (!key)
          return innerKey;
        return options.objectKeysNotation === "brackets" ? `${key}[${innerKey}]` : `${key}.${innerKey}`;
      })();
      serialize(realInnerKey, innerValue, options, formData);
    });
    return;
  }
  if (isNumeric(value)) {
    formData.append(key, value.toString());
    return;
  }
  if (isString(value) || isFunction(value?.toString)) {
    formData.append(key, value.toString());
  }
};
var objectToFormdata = (object, userOptions, existingFormData) => {
  const options = { ...DEFAULT_OPTIONS4, ...userOptions };
  const formData = existingFormData ?? new FormData();
  serialize("", object, options, formData);
  return formData;
};

// src/objects/omit/omit.ts
var omit = (obj, ...keys) => Object.fromEntries(Object.entries(obj ?? {}).filter(([k]) => !keys.includes(k)));

// src/objects/pick/pick.ts
var pick = (obj, ...keys) => Object.fromEntries(
  keys.filter((key) => key in obj).map((key) => [key, obj[key]])
);

// src/dates/dates.utils.ts
var ISO_DATETIME_REG_EXP = /^(\d{4})-(0[1-9]|1[02])-(0[1-9]|[12]\d|3[01])(?:[ T](0\d|1\d|2[0-3]):([0-5]\d):([0-5]\d)(?:\.(\d{3}))?(?:Z|([+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?))?)?$/;
var RU_DATETIME_REG_EXP = /^([1-9]|0\d|[12]\d|3[01])\.(0[1-9]|[1-9]|1[0-2])\.(\d{4})(?:\s*([01]\d|2[0-3]|\d)(?::(0\d|[1-5]\d|\d))?(?::(0\d|[1-5]\d|\d))?(?:.(\d{3}))?)?$/;
var EN_DATETIME_REG_EXP = /^(0[1-9]|[1-9]|1[0-2])\/([1-9]|0\d|[12]\d|3[01])\/(\d{4})(?:\s*([01]\d|2[0-3]|\d)(?::(0\d|[1-5]\d|\d))?(?::(0\d|[1-5]\d|\d))?(?:.(\d{3}))?)?$/;
var prefixedDateMethodsFactory = (type, utc) => {
  return (string) => {
    const prefix = /* @__PURE__ */ (() => {
      const value = type === "get" ? utc ? "getUTC" : "get" : utc ? "setUTC" : "set";
      return value;
    })();
    return `${prefix}${string}`;
  };
};
var createDateFromTokens = (tokens) => {
  const date = new Date(Date.UTC(tokens.year, tokens.month, tokens.day));
  if (date.getUTCMonth() !== tokens.month || date.getUTCDate() !== tokens.day) {
    return null;
  }
  date.setUTCHours(tokens.hours);
  date.setUTCMinutes(tokens.minutes);
  date.setUTCSeconds(tokens.seconds);
  date.setUTCMilliseconds(tokens.milliseconds);
  if (!tokens.offset)
    return date;
  date.setUTCMinutes(date.getUTCMinutes() + tokens.offset);
  return date;
};

// src/dates/parse-date/parse-date.ts
var tokensFromDate = (date, utc) => {
  if (!date)
    return null;
  const get = prefixedDateMethodsFactory("get", utc);
  date.setUTCMinutes(date.getUTCMinutes() + (/* @__PURE__ */ new Date()).getTimezoneOffset());
  const year = date[get("FullYear")]();
  const month = date[get("Month")]();
  const day = date[get("Date")]();
  const hours = date[get("Hours")]();
  const minutes = date[get("Minutes")]();
  const seconds = date[get("Seconds")]();
  const milliseconds = date[get("Milliseconds")]();
  return { year, month, day, hours, minutes, seconds, milliseconds };
};
var DEFAULT_OPTIONS5 = { utc: false };
var parseDate = (input, userOptions) => {
  const options = { ...DEFAULT_OPTIONS5, ...userOptions };
  if (isDate(input)) {
    if (!isDate(input, true))
      return null;
    const year = input.getFullYear();
    const month = input.getMonth();
    const day = input.getDate();
    const hours = input.getHours();
    const minutes = input.getMinutes();
    const seconds = input.getSeconds();
    const milliseconds = input.getMilliseconds();
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds }),
      options.utc
    );
  }
  if (isInteger(input)) {
    return tokensFromDate(new Date(input), options.utc);
  }
  let match = input.match(ISO_DATETIME_REG_EXP);
  if (match) {
    const [
      year,
      month,
      day,
      hours,
      minutes,
      seconds,
      milliseconds,
      offset
    ] = match.slice(1).map((part, index) => {
      if (isUndefined(part))
        return 0;
      if (index === 1)
        return Number(part) - 1;
      if (index === 7) {
        const [sign, offsetString] = [part[0], part.slice(1)];
        const offset2 = (() => {
          if (offsetString.length === 2) {
            return Number(offsetString) * 60;
          }
          if (offsetString.length === 4) {
            return Number(offsetString.slice(0, 2)) * 60 + Number(offsetString.slice(2));
          }
          return Number(offsetString.slice(0, 2)) * 60 + Number(offsetString.slice(3));
        })();
        return sign === "+" ? offset2 : -offset2;
      }
      return Number(part);
    });
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds, offset }),
      options.utc
    );
  }
  match = input.match(RU_DATETIME_REG_EXP);
  if (match) {
    const [
      day,
      month,
      year,
      hours,
      minutes,
      seconds,
      milliseconds
    ] = match.slice(1).map((part, index) => {
      if (isUndefined(part))
        return 0;
      if (index === 1)
        return Number(part) - 1;
      return Number(part);
    });
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds }),
      options.utc
    );
  }
  match = input.match(EN_DATETIME_REG_EXP);
  if (match) {
    const [
      month,
      day,
      year,
      hours,
      minutes,
      seconds,
      milliseconds
    ] = match.slice(1).map((part, index) => {
      if (isUndefined(part))
        return 0;
      if (index === 0)
        return Number(part) - 1;
      return Number(part);
    });
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds }),
      options.utc
    );
  }
  return null;
};

// src/dates/to-date/to-date.ts
var DEFAULT_OPTIONS6 = { utc: false };
var toDate = (value, userOptions) => {
  const options = { ...DEFAULT_OPTIONS6, ...userOptions };
  const tokens = parseDate(value, { utc: options.utc });
  if (!tokens)
    return null;
  const offset = (/* @__PURE__ */ new Date()).getTimezoneOffset();
  return createDateFromTokens({
    ...tokens,
    offset: options.utc ? -offset : offset
  });
};

// src/dates/format-date/format-date.locales.ts
var FORMAT_DATE_LOCALE_EN = {
  name: "en",
  values: {
    firstDayOfWeekIndex: 0,
    dayNames: {
      abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    },
    monthNames: {
      abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    }
  }
};
var FORMAT_DATE_LOCALE_RU = {
  name: "ru",
  values: {
    firstDayOfWeekIndex: 1,
    dayNames: {
      abbreviated: ["\u0412\u0441", "\u041F\u043D", "\u0412\u0442", "\u0421\u0440", "\u0427\u0442", "\u041F\u0442", "\u0421\u0431"],
      wide: [
        ["\u0412\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435", "\u0412 \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435"],
        ["\u041F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A", "\u0412 \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A"],
        ["\u0412\u0442\u043E\u0440\u043D\u0438\u043A", "\u0412\u043E \u0432\u0442\u043E\u0440\u043D\u0438\u043A"],
        ["\u0421\u0440\u0435\u0434\u0430", "\u0412 \u0441\u0440\u0435\u0434\u0443"],
        ["\u0427\u0435\u0442\u0432\u0435\u0440\u0433", "\u0412 \u0447\u0435\u0442\u0432\u0435\u0440\u0433"],
        ["\u041F\u044F\u0442\u043D\u0438\u0446\u0430", "\u0412 \u043F\u044F\u0442\u043D\u0438\u0446\u0443"],
        ["\u0421\u0443\u0431\u0431\u043E\u0442\u0430", "\u0412 \u0441\u0443\u0431\u0431\u043E\u0442\u0443"]
      ]
    },
    monthNames: {
      abbreviated: ["\u042F\u043D\u0432", "\u0424\u0435\u0432", "\u041C\u0430\u0440\u0442", "\u0410\u043F\u0440", "\u041C\u0430\u0439", "\u0418\u044E\u043D\u044C", "\u0418\u044E\u043B\u044C", "\u0410\u0432\u0433", "\u0421\u0435\u043D", "\u041E\u043A\u0442", "\u041D\u043E\u044F", "\u0414\u0435\u043A"],
      wide: [
        ["\u042F\u043D\u0432\u0430\u0440\u044C", "\u042F\u043D\u0432\u0430\u0440\u044F"],
        ["\u0424\u0435\u0432\u0440\u0430\u043B\u044C", "\u0424\u0435\u0432\u0440\u0430\u043B\u044F"],
        ["\u041C\u0430\u0440\u0442", "\u041C\u0430\u0440\u0442\u0430"],
        ["\u0410\u043F\u0440\u0435\u043B\u044C", "\u0410\u043F\u0440\u0435\u043B\u044F"],
        ["\u041C\u0430\u0439", "\u041C\u0430\u044F"],
        ["\u0418\u044E\u043D\u044C", "\u0418\u044E\u043D\u044F"],
        ["\u0418\u044E\u043B\u044C", "\u0418\u044E\u043B\u044F"],
        ["\u0410\u0432\u0433\u0443\u0441\u0442", "\u0410\u0432\u0433\u0443\u0441\u0442\u0430"],
        ["\u0421\u0435\u043D\u0442\u044F\u0431\u0440\u044C", "\u0421\u0435\u043D\u0442\u044F\u0431\u0440\u044F"],
        ["\u041E\u043A\u0442\u044F\u0431\u0440\u044C", "\u041E\u043A\u0442\u044F\u0431\u0440\u044F"],
        ["\u041D\u043E\u044F\u0431\u0440\u044C", "\u041D\u043E\u044F\u0431\u0440\u044F"],
        ["\u0414\u0435\u043A\u0430\u0431\u0440\u044C", "\u0414\u0435\u043A\u0430\u0431\u0440\u044F"]
      ]
    }
  }
};

// src/dates/format-date/format-date.utils.ts
var TOKEN = /H{1,2}|L{1,4}|M{1,4}|X{1,3}|_L{3,4}|_M{3,4}|_c{3,4}|_e{3,4}|c{1,4}|d{1,2}|e{1,4}|h{1,2}|m{1,2}|s{1,2}|yy(?:yy)?|\[[^\]]*]/g;
var ORDERED_DAY_INDICES = [0, 1, 2, 3, 4, 5, 6];
var pad = (value, length = 2) => padStart(value, length, "0");

// src/dates/format-date/format-date.ts
var _formatDate = (pattern, locales, input, options) => {
  const { utc, locale } = options;
  const date = toDate(input);
  if (!date)
    return null;
  const $i18n = locales.find(({ name }) => name === locale)?.values;
  if (!$i18n) {
    throw new Error(`The locale object for locale \`${locale}\` does not exists.`);
  }
  const localized = (entity, type, variant, index) => {
    const _type = toArray($i18n[`${entity}Names`][type][index]);
    return variant === "standalone" ? _type[0] : _type[1] ?? _type[0];
  };
  const get = prefixedDateMethodsFactory("get", utc);
  const day = () => date[get("Date")]();
  const weekday = () => date[get("Day")]();
  const month = () => date[get("Month")]();
  const year = () => date[get("FullYear")]();
  const hours = () => date[get("Hours")]();
  const minutes = () => date[get("Minutes")]();
  const seconds = () => date[get("Seconds")]();
  const weekdayIndex = () => {
    const offset = weekday() - $i18n.firstDayOfWeekIndex;
    return ORDERED_DAY_INDICES.at(offset) + 1;
  };
  const timezone = (format) => {
    const offset = utc ? 0 : date.getTimezoneOffset();
    if (offset === 0)
      return "Z";
    const sign = offset < 0 ? "+" : "-";
    const offsetHours = Math.floor(Math.abs(offset) / 60);
    const offsetMinutes = Math.abs(offset) - offsetHours * 60;
    const joinCharacter = ["basic", "minimal"].includes(format) ? "" : ":";
    const filterer = format === "minimal" ? (value) => value !== 0 : (value) => true;
    const time = [offsetHours, offsetMinutes].filter((value) => filterer(value)).map((part) => pad(part)).join(joinCharacter);
    return `${sign}${time}`;
  };
  const matchers = {
    // Year
    yy: () => year().toString().slice(-2),
    yyyy: () => pad(year(), 4),
    // Month (standalone)
    L: () => month() + 1,
    LL: () => pad(month() + 1),
    LLL: () => localized("month", "abbreviated", "standalone", month()),
    _LLL: () => localized("month", "abbreviated", "standalone", month()).toLocaleLowerCase(),
    LLLL: () => localized("month", "wide", "standalone", month()),
    _LLLL: () => localized("month", "wide", "standalone", month()).toLocaleLowerCase(),
    // Month (format)
    M: () => month() + 1,
    MM: () => pad(month() + 1),
    MMM: () => localized("month", "abbreviated", "format", month()),
    _MMM: () => localized("month", "abbreviated", "format", month()).toLocaleLowerCase(),
    MMMM: () => localized("month", "wide", "format", month()),
    _MMMM: () => localized("month", "wide", "format", month()).toLocaleLowerCase(),
    // Weekday (standalone)
    c: () => weekdayIndex(),
    cc: () => pad(weekdayIndex()),
    ccc: () => localized("day", "abbreviated", "standalone", weekday()),
    _ccc: () => localized("day", "abbreviated", "standalone", weekday()).toLocaleLowerCase(),
    cccc: () => localized("day", "wide", "standalone", weekday()),
    _cccc: () => localized("day", "wide", "standalone", weekday()).toLocaleLowerCase(),
    // Weekday (format)
    e: () => weekdayIndex(),
    ee: () => pad(weekdayIndex()),
    eee: () => localized("day", "abbreviated", "format", weekday()),
    _eee: () => localized("day", "abbreviated", "format", weekday()).toLocaleLowerCase(),
    eeee: () => localized("day", "wide", "format", weekday()),
    _eeee: () => localized("day", "wide", "format", weekday()).toLocaleLowerCase(),
    // Day
    d: () => day(),
    dd: () => pad(day()),
    // Hours
    h: () => hours() % 12 || 12,
    hh: () => pad(hours() % 12 || 12),
    H: () => hours(),
    HH: () => pad(hours()),
    // Minutes
    m: () => minutes(),
    mm: () => pad(minutes()),
    // Seconds
    s: () => seconds(),
    ss: () => pad(seconds()),
    // Timezone as JS-compatible string
    X: () => timezone("minimal"),
    XX: () => timezone("basic"),
    XXX: () => timezone("extended")
  };
  return pattern.replaceAll(TOKEN, (match) => {
    if (match in matchers) {
      return matchers[match]();
    }
    return match.slice(1, -1);
  });
};
var createFormatDate = (localeData, defaultOptions3) => {
  return (pattern, input = /* @__PURE__ */ new Date(), options) => {
    return _formatDate(pattern, toArray(localeData), input, mergeObjects(defaultOptions3, options));
  };
};
var formatDate = createFormatDate([FORMAT_DATE_LOCALE_EN, FORMAT_DATE_LOCALE_RU], { utc: false, locale: "en" });
var formatDateRu = createFormatDate(FORMAT_DATE_LOCALE_RU, { utc: false, locale: "ru" });
var formatDateEn = createFormatDate(FORMAT_DATE_LOCALE_EN, { utc: false, locale: "en" });

// src/dates/is-iso-date/is-iso-date.ts
var isIsoDate = (input, strict = false) => {
  if (!isString(input))
    return false;
  const match = input.match(ISO_DATETIME_REG_EXP);
  if (!strict)
    return !!match;
  if (!match)
    return false;
  const [year, month, day] = match.slice(1).map(Number);
  const date = new Date(Date.UTC(year, month - 1, day, 0, 0, 0, 0));
  return date.getUTCMonth() === month - 1 && date.getUTCDate() === day;
};

// src/dates/is-leap-year/is-leap-year.ts
var isLeapYear = (value) => {
  const year = (() => {
    if (isInteger(value))
      return value;
    if (isString(value)) {
      const maybeNumber = +value;
      return Number.isNaN(maybeNumber) ? null : maybeNumber;
    }
    if (isDate(value, true))
      return value.getFullYear();
    return null;
  })();
  if (isNull(year))
    return false;
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};

// src/numbers/format-bytes/format-bytes.ts
var REFERENCE_TABLE = {
  metric: [
    { from: 0, to: 1e3, prefix: "b" },
    { from: 1e3, to: 1e6, prefix: "k" },
    { from: 1e6, to: 1e9, prefix: "m" },
    { from: 1e9, to: 1e12, prefix: "g" },
    { from: 1e12, to: 1e15, prefix: "t" },
    { from: 1e15, to: 1e18, prefix: "p" },
    { from: 1e18, to: 1e21, prefix: "e" },
    { from: 1e21, to: 1e24, prefix: "z" },
    { from: 1e24, to: 1e27, prefix: "y" }
  ],
  IEC: [
    { from: 0, to: 1024 ** 1, prefix: "b" },
    { from: 1024 ** 1, to: 1024 ** 2, prefix: "k" },
    { from: 1024 ** 2, to: 1024 ** 3, prefix: "m" },
    { from: 1024 ** 3, to: 1024 ** 4, prefix: "g" },
    { from: 1024 ** 4, to: 1024 ** 5, prefix: "t" },
    { from: 1024 ** 5, to: 1024 ** 6, prefix: "p" },
    { from: 1024 ** 6, to: 1024 ** 7, prefix: "e" },
    { from: 1024 ** 7, to: 1024 ** 8, prefix: "z" },
    { from: 1024 ** 8, to: 1024 ** 9, prefix: "y" }
  ]
};
var UNITS_DEFAULTS = {
  metric: {
    b: "B",
    k: "kB",
    m: "MB",
    g: "GB",
    t: "TB",
    p: "PB",
    e: "EB",
    z: "ZB",
    y: "YB"
  },
  IEC: {
    b: "B",
    k: "KiB",
    m: "MiB",
    g: "GiB",
    t: "TiB",
    p: "PiB",
    e: "EiB",
    z: "ZiB",
    y: "YiB"
  }
};
var DEFAULT_OPTIONS7 = {
  precision: 1,
  to: "auto",
  trimZeros: true,
  mode: "metric",
  toString: (value, valueAsString, unit, isInteger2) => `${valueAsString} ${unit}`
};
var _options = /* @__PURE__ */ new WeakMap();
var FormatBytes = class {
  /**
   * The calculated value.
   */
  value;
  /**
   * The calculated value in string form with needed precision.
   */
  valueAsString;
  /**
   * Calculated unit of value.
   */
  unit;
  /**
   * Whether the value is an integer number. \
   * Mostly used for `i18n` purposes.
   */
  isInteger;
  constructor(bytes, customOptions) {
    if (!isInteger(bytes))
      bytes = 0;
    const options = mergeObjects(DEFAULT_OPTIONS7, customOptions);
    _options.set(this, options);
    const referenceTable = REFERENCE_TABLE[options.mode];
    const entry = options.to === "auto" ? referenceTable.find((e) => bytes >= e.from && bytes < e.to) ?? referenceTable[0] : referenceTable.find((i) => i.prefix === options.to) ?? referenceTable[0];
    const { from, prefix } = entry;
    const unitsReferenceTable = mergeObjects(UNITS_DEFAULTS, options.customUnits);
    const unit = unitsReferenceTable[options.mode][prefix];
    let value = bytes / from;
    value = Number.isFinite(value) ? value : bytes;
    let valueAsString = value.toFixed(options.precision);
    value = parseFloat(valueAsString);
    if (options.trimZeros) {
      value = parseFloat(valueAsString);
      valueAsString = value.toString();
    }
    const isInteger2 = isInteger(value);
    this.value = value;
    this.valueAsString = valueAsString;
    this.unit = unit;
    this.isInteger = isInteger2;
  }
  toString() {
    const { value, valueAsString, unit, isInteger: isInteger2 } = this;
    const options = _options.get(this);
    return options.toString(value, valueAsString, unit, isInteger2);
  }
};
var formatBytes = (bytes, customOptions) => new FormatBytes(bytes, customOptions);
var formatBytesRu = (bytes, _customOptions) => {
  const customOptions = mergeObjects({
    // Not sure actually, it's not reglamented ¯\_(ツ)_/¯
    customUnits: {
      metric: {
        b: "\u0411",
        k: "\u041A\u0411",
        m: "\u041C\u0411",
        g: "\u0413\u0411",
        t: "\u0422\u0411",
        p: "\u041F\u0411",
        e: "\u0415\u0411",
        z: "\u0417\u0411",
        y: "\u0418\u0411"
      },
      IEC: {
        b: "\u0411",
        k: "\u041A\u0431",
        m: "\u041C\u0431",
        g: "\u0413\u0431",
        t: "\u0422\u0431",
        p: "\u041F\u0431",
        e: "\u0415\u0431",
        z: "\u0417\u0431",
        y: "\u0418\u0431"
      }
    }
  }, _customOptions);
  return new FormatBytes(bytes, customOptions);
};

// src/numbers/number-format/number-format.ts
var numberFormat = (numberOrStringRepresentingNumber, decimals = 0, fractionSeparator = ".", thousandsSeparator = "\xA0") => {
  const number = toNumber(numberOrStringRepresentingNumber, 0);
  const toFixedFix = () => {
    const k = 10 ** decimals;
    return Math.round(number * k) / k;
  };
  const parts = String(decimals ? toFixedFix() : Math.round(number)).split(".");
  let [int, fraction = ""] = parts;
  if (int.length > 3) {
    int = int.replaceAll(/\B(?=(?:\d{3})+(?!\d))/g, thousandsSeparator);
  }
  if (fraction.length < decimals) {
    fraction += arrayOfLength(decimals - fraction.length + 1).join("0");
  }
  return [int, fraction].filter(Boolean).join(fractionSeparator);
};

// src/numbers/precision/precision.ts
var precision = (maybeNumber) => {
  const value = toNumber(maybeNumber, null);
  if (value === null || !Number.isFinite(value))
    return null;
  let e = 1;
  let p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p++;
  }
  return p;
};

// src/numbers/random-float/random-float.ts
var randomFloat = (min, max, precision2 = 1) => parseFloat((Math.random() * (max - min) + min).toFixed(precision2));

// src/dates/random-date/random-date.ts
var setTime = (date, hours, minutes, seconds, milliseconds) => {
  hours = clamp(hours, 0, 23);
  minutes = clamp(minutes, 0, 59);
  seconds = clamp(seconds, 0, 59);
  milliseconds = clamp(milliseconds, 0, 999);
  date.setHours(hours);
  date.setMinutes(minutes);
  date.setSeconds(seconds);
  date.setMilliseconds(milliseconds);
};
var randomDate = (start = /* @__PURE__ */ new Date(0), end = /* @__PURE__ */ new Date(), userOptions) => {
  if (!isDate(start, true))
    start = /* @__PURE__ */ new Date(0);
  if (!isDate(end, true))
    end = /* @__PURE__ */ new Date();
  const date = new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
  if (isUndefined(userOptions))
    return date;
  if (isString(userOptions.time)) {
    const [time, milliseconds = 0] = userOptions.time.split(".");
    const [hours = 0, minutes = 0, seconds = 0] = time.split(":").map((maybeNumber) => {
      const number = Number(maybeNumber);
      return Number.isNaN(number) ? 0 : number;
    });
    setTime(date, hours, minutes, seconds, +milliseconds);
  }
  if (isArray(userOptions.time)) {
    const [hours = 0, minutes = 0, seconds = 0, milliseconds = 0] = userOptions.time;
    setTime(date, hours, minutes, seconds, milliseconds);
  }
  return date;
};

// src/dom/get-document-size/get-document-size.ts
var getDocumentSize = (axis = "y") => {
  const scrollWidth = Math.max(
    document.body.scrollWidth,
    document.documentElement.scrollWidth,
    document.body.offsetWidth,
    document.documentElement.offsetWidth,
    document.body.clientWidth,
    document.documentElement.clientWidth
  );
  const scrollHeight = Math.max(
    document.body.scrollHeight,
    document.documentElement.scrollHeight,
    document.body.offsetHeight,
    document.documentElement.offsetHeight,
    document.body.clientHeight,
    document.documentElement.clientHeight
  );
  return axis === "both" ? { x: scrollWidth, y: scrollHeight } : axis === "x" ? scrollWidth : scrollHeight;
};

// src/dom/get-element/get-element.ts
var getElement = (value, parent = null) => {
  if (isString(parent)) {
    parent = document.querySelector(parent);
  }
  if (isString(value)) {
    return isElement(parent) ? parent.querySelector(value) : document.querySelector(value);
  }
  if (isElement(value)) {
    return isElement(parent) ? parent.contains(value) ? value : null : value;
  }
  return null;
};

// src/dom/get-window-scroll/get-window-scroll.ts
var getScrollTop = () => Math.max(window.pageYOffset || 0, window.scrollY || 0, document.documentElement.scrollTop, document.body.scrollTop);
var getScrollLeft = () => Math.max(window.pageXOffset || 0, window.scrollX || 0, document.documentElement.scrollLeft, document.body.scrollLeft);
var getWindowScroll = (axis = "y") => {
  if (axis === "y")
    return getScrollTop();
  if (axis === "x")
    return getScrollLeft();
  return { x: getScrollLeft(), y: getScrollTop() };
};

// src/dom/get-element-offset/get-element-offset.ts
var getElementScroll = (el, axis = "both") => {
  if (axis === "both") {
    return { x: el.scrollLeft, y: el.scrollTop };
  }
  return axis === "x" ? el.scrollLeft : el.scrollTop;
};
var getElementOffset = (el, axis = "both", parent = window) => {
  const parentRect = parent === window || parent === null ? { top: 0, left: 0 } : parent.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  const top = elRect.top - parentRect.top;
  const left = elRect.left - parentRect.left;
  const scroll = parent === window || !parent ? getWindowScroll(axis) : getElementScroll(parent, axis);
  if (axis === "y")
    return top + scroll;
  if (axis === "x")
    return left + scroll;
  return {
    // @ts-expect-error -- TODO
    x: left + scroll.x,
    // @ts-expect-error -- TODO
    y: top + scroll.y
  };
};

// src/dom/get-scroll-limit/get-scroll-limit.ts
var toMax = (v) => Math.max(0, v);
var getScrollLimit = (axis = "y") => {
  if (axis === "both") {
    const ds2 = getDocumentSize(axis);
    return {
      x: toMax(ds2.x - window.innerWidth),
      y: toMax(ds2.y - window.innerHeight)
    };
  }
  const ds = getDocumentSize(axis);
  return axis === "x" ? toMax(ds - window.innerWidth) : toMax(ds - window.innerHeight);
};

// src/dom/get-scrollable-ancestor/get-scrollable-ancestor.ts
var getScrollableAncestor = (element, axis = "both") => {
  let el = element;
  while (el?.parentElement) {
    el = el.parentElement;
    if (el === document.body)
      return window;
    if (el === document.documentElement)
      return window;
    const styles = window.getComputedStyle(el);
    const toCheck = [];
    ["both", "x"].includes(axis) && toCheck.push(styles.getPropertyValue("overflow-x"));
    ["both", "y"].includes(axis) && toCheck.push(styles.getPropertyValue("overflow-y"));
    const isScrollable = toCheck.some((val) => ["auto", "scroll"].includes(val));
    if (isScrollable)
      return el;
  }
  return window;
};

// src/dom/get-scrollbar-width/get-scrollbar-width.ts
var getScrollbarWidth = (el = document.body) => {
  return el === document.body ? window.innerWidth - document.documentElement.clientWidth : el.offsetWidth - el.clientWidth;
};

// src/environment/is-client/is-client.ts
var isClient = () => typeof window !== "undefined";

// src/environment/is-dev/is-dev.ts
var isDev = () => {
  if (typeof process === "undefined")
    return null;
  return process.env.NODE_ENV === "development";
};

// src/environment/is-firefox/is-firefox.ts
var isFirefox = () => !!navigator.userAgent.toLowerCase().match(/firefox./);

// src/environment/is-internet-explorer/is-internet-explorer.ts
var isInternetExplorer = () => !!navigator.userAgent.toLowerCase().match(/trident./);

// src/environment/is-lighthouse/is-lighthouse.ts
var isLighthouse = (userAgent) => {
  if (!userAgent && isClient()) {
    userAgent = window.navigator.userAgent;
  }
  return ["Lighthouse", "Page Speed", "PageSpeed"].some((part) => (userAgent ?? "").includes(part));
};

// src/environment/is-mobile/is-mobile.ts
var isMobile = () => /android|blackberry|iemobile|ipad|iphone|ipod|opera mini|webos/i.test(navigator.userAgent);

// src/environment/is-motionless/is-motionless.ts
var isMotionless = () => window.matchMedia("(prefers-reduced-motion: reduce)").matches;

// src/environment/is-osx/is-osx.ts
var isOSX = () => {
  const platform = navigator.userAgentData?.platform || navigator.platform || "";
  return !!platform.match(/(ipad|iphone|ipod|mac)/i);
};

// src/environment/is-prod/is-prod.ts
var isProd = () => {
  if (typeof process === "undefined")
    return null;
  return process.env.NODE_ENV === "production";
};

// src/environment/is-server/is-server.ts
var isServer = () => typeof window === "undefined";

// src/environment/is-test/is-test.ts
var isTest = () => process.env.NODE_ENV === "test";

// src/environment/is-touch/is-touch.ts
var isTouch = () => "ontouchstart" in window || !!navigator?.msMaxTouchPoints;

// src/environment/supports-passive/supports-passive.ts
var supportsPassive = () => {
  let supports = false;
  const options = Object.defineProperty({}, "passive", {
    get() {
      supports = true;
      return null;
    }
  });
  try {
    const noop2 = () => {
    };
    window.addEventListener("test:passive", noop2, options);
    window.removeEventListener("test:passive", noop2, options);
  } catch {
  }
  return supports;
};

// src/functions/compose/compose.ts
var compose = (...functions) => (value) => [...functions].reverse().reduce((acc, curr) => acc = curr(acc), value);

// src/functions/debounce/debounce.ts
var debounce = (fn, delay = 60, immediate = false) => {
  let timer;
  let started = false;
  const debounced = function(...args) {
    if (!started) {
      if (immediate)
        fn.apply(this, args);
      started = true;
    }
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
      started = false;
    }, delay);
  };
  return debounced;
};

// src/functions/hash/hash.ts
var import_ohash = require("ohash");
var hash = (value, options) => (0, import_ohash.hash)(value, options);

// src/functions/noop/noop.ts
var noop = () => {
};

// src/functions/safe-json-parse/safe-json-parse.ts
var safeJsonParse = (jsonString, reviver) => {
  if (!isString(jsonString))
    return null;
  try {
    return JSON.parse(jsonString, reviver);
  } catch {
    return null;
  }
};

// src/functions/sleep/sleep.ts
var sleep = async (duration = 0) => new Promise((resolve2) => setTimeout(resolve2, duration));

// src/functions/throttle/throttle.ts
var parseOptions = (optionsOrDelay) => {
  if (isObject(optionsOrDelay)) {
    return [
      optionsOrDelay.delay ?? 0,
      optionsOrDelay.leading ?? true,
      optionsOrDelay.trailing ?? true
    ];
  }
  return [optionsOrDelay ?? 0, true, true];
};
var throttle = (callback, optionsOrDelay) => {
  const [delay, leading, trailing] = parseOptions(optionsOrDelay);
  let timeoutID = null;
  let cancelled;
  let lastExec = leading ? 0 : Date.now();
  const clearExistingTimeout = () => {
    if (!timeoutID)
      return;
    clearTimeout(timeoutID);
    timeoutID = null;
  };
  const cancel = () => {
    clearExistingTimeout();
    cancelled = true;
  };
  const trailingExec = (exec) => {
    if (!trailing)
      return;
    clearExistingTimeout();
    timeoutID ||= setTimeout(exec, delay);
  };
  function wrapper(...args) {
    if (cancelled)
      return;
    const self = this;
    const exec = () => {
      lastExec = Date.now();
      callback.apply(self, args);
    };
    trailingExec(exec);
    const runTime = Date.now() - lastExec;
    if (runTime > delay)
      exec();
  }
  wrapper.cancel = cancel;
  return wrapper;
};

// src/functions/verify-file-accept/verify-file-accept.ts
var verifyFileAccept = (file, accept) => {
  if (!accept)
    return true;
  const parts = accept.split(",").map((part) => part.trim());
  const extensionParts = parts.filter((part) => part.startsWith("."));
  const mimeParts = parts.filter((part) => !part.startsWith(".")).join(",");
  const mimeResult = mimeParts ? new RegExp(mimeParts.replaceAll("*", ".*").replaceAll(",", "|")).test(file.type) : false;
  return mimeResult || extensionParts.some((part) => file.name.endsWith(part));
};

// src/functions/with-probability/with-probability.utils.ts
var toNumericProbability = (value) => {
  let isPercentage = false;
  if (isString(value)) {
    isPercentage = value.trim().endsWith("%");
    value = +value.replaceAll(/[^\d\-.]/g, "");
  }
  if (Number.isNaN(value))
    return 0;
  if (value > 1)
    isPercentage = true;
  if (isPercentage) {
    value = clamp(value, 0, 100);
    return value / 100;
  }
  return clamp(value, 0, 1);
};
var toValue = (value) => isFunction(value) ? value() : value;

// src/functions/with-probability/with-probability.ts
var withProbability = (probability, primaryValue, secondaryValue) => {
  if (probability === 1)
    return toValue(primaryValue);
  if (probability === 0)
    return toValue(secondaryValue);
  return Math.random() > toNumericProbability(probability) ? toValue(secondaryValue) : toValue(primaryValue);
};

// src/math/angle/angle.ts
function angle(arg1, arg2, arg3, arg4) {
  const [p1, p2] = (() => {
    if (isObject(arg1) && isObject(arg2)) {
      return [[arg1.x, arg1.y], [arg2.x, arg2.y]];
    }
    if (isArray(arg1) && isArray(arg2)) {
      return [arg1, arg2];
    }
    if (isNumeric(arg1) && isNumeric(arg2) && isNumeric(arg3) && isNumeric(arg4)) {
      return [[arg1, arg2], [arg3, arg4]];
    }
    return [null, null];
  })();
  if (isNull(p1) || isNull(p2))
    return null;
  const [[x1, y1], [x2, y2]] = [p1, p2];
  const [dx, dy] = [x2 - x1, y2 - y1];
  const theta = Math.atan2(dx, dy) * 180 / Math.PI;
  return theta < 0 ? theta + 360 : theta;
}

// src/math/distance/distance.ts
function distance(arg1, arg2, arg3, arg4) {
  const [p1, p2] = (() => {
    if (isObject(arg1) && isObject(arg2)) {
      return [[arg1.x, arg1.y], [arg2.x, arg2.y]];
    }
    if (isArray(arg1) && isArray(arg2)) {
      return [arg1, arg2];
    }
    if (isNumeric(arg1) && isNumeric(arg2) && isNumeric(arg3) && isNumeric(arg4)) {
      return [[arg1, arg2], [arg3, arg4]];
    }
    return [null, null];
  })();
  if (isNull(p1) || isNull(p2))
    return null;
  const [[x1, y1], [x2, y2]] = [p1, p2];
  return Math.hypot(x1 - x2, y1 - y2);
}

// src/math/gcd/gcd.ts
var _gcdBinary = (a, b) => {
  let factor = 1;
  while (a % 2 === 0 && b % 2 === 0) {
    [a, b, factor] = [a / 2, b / 2, factor * 2];
  }
  while (a % 2 === 0)
    a = a / 2;
  while (b) {
    while (b % 2 === 0)
      b = b / 2;
    if (a > b)
      [a, b] = [b, a];
    b = b - a;
  }
  return factor * a;
};
var _gcdBitwise = (a, b) => {
  let factor = 0;
  while ((a & 1) === 0 && (b & 1) === 0) {
    a >>>= 1;
    b >>>= 1;
    factor++;
  }
  while ((a & 1) === 0)
    a >>>= 1;
  while (b) {
    while ((b & 1) === 0)
      b >>>= 1;
    if (a > b)
      [a, b] = [b, a];
    b = b - a;
  }
  return a << factor;
};
var _gcd = (a, b) => {
  if (a === 0)
    return b;
  if (b === 0)
    return a;
  [a, b] = [Math.abs(a), Math.abs(b)];
  const mode = a < Number.MAX_SAFE_INTEGER && b < Number.MAX_SAFE_INTEGER ? "bitwise" : "binary";
  return mode === "binary" ? _gcdBinary(a, b) : _gcdBitwise(a, b);
};
function gcd(...args) {
  const numbers = isArray(args[0]) ? args[0] : args;
  const { length } = numbers;
  if (length < 2)
    return null;
  if (numbers.some((number) => !isInteger(number)))
    return null;
  return numbers.reduce((acc, b) => _gcd(acc, b));
}

// src/math/lerp/lerp.ts
var lerp = (start, end, amount) => {
  return (1 - amount) * start + amount * end;
};

// src/promises/min-time-promise/min-time-promise.ts
var minTimePromise = async (promise, minTime = 0) => {
  const startTime = Date.now();
  let errorTime = null;
  const result = await Promise.all([promise, sleep(minTime)]).catch((e) => {
    errorTime = Date.now();
    return [e];
  });
  if (errorTime) {
    await sleep(clamp(minTime - (errorTime - startTime), 0));
    throw result[0];
  }
  return result[0];
};

// src/promises/promise-controller/promise-controller.ts
var promiseController = () => {
  let resolve2;
  let reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve2 = _resolve;
    reject = _reject;
  });
  promise.resolve = resolve2;
  promise.reject = reject;
  return promise;
};

// src/ranges/range-includes/range-includes.ts
var rangeIncludes = (value, ranges, mode = "any") => {
  if (Number.isNaN(value))
    return false;
  const method = mode === "all" ? "every" : "some";
  return (ranges ?? [])[method](([min, max]) => {
    if (Number.isNaN(min) || Number.isNaN(max))
      return false;
    if (!isNullish(min) && value < min)
      return false;
    if (!isNullish(max) && value > max)
      return false;
    return true;
  });
};

// src/ranges/ranges-crop/ranges-crop.ts
var rangesCrop = (ranges, start = null, end = null, infinityToNull = false) => {
  if (isEmpty(ranges))
    return [];
  if (isNullish(start))
    start = -Infinity;
  if (isNullish(end))
    end = Infinity;
  return rangesMerge(ranges, true, infinityToNull).map((range) => [
    isNullish(range[0]) ? -Infinity : range[0],
    isNullish(range[1]) ? Infinity : range[1]
  ]).filter((range) => range[1] >= start && range[0] <= end).map((range) => {
    let [first, second] = range;
    if (first < start)
      first = start;
    if (second > end)
      second = end;
    return [
      formatInfinity(first, infinityToNull),
      formatInfinity(second, infinityToNull)
    ];
  });
};

// src/ranges/ranges-invert/ranges-invert.ts
var rangesInvert = (ranges, start = null, end = null, infinityToNull = false) => {
  if (isNullish(start))
    start = -Infinity;
  if (isNullish(end))
    end = Infinity;
  return rangesCrop(
    rangesMerge(ranges, true, infinityToNull).reduce((acc, range, i, arr) => {
      const res = [];
      if (i === 0 && arr[0][0] > start) {
        res.push([
          formatInfinity(start, infinityToNull),
          formatInfinity(arr[0][0], infinityToNull)
        ]);
      }
      const tail = i < arr.length - 1 ? arr[i + 1][0] : end;
      if (!rangeIncludes(end, [range])) {
        res.push([
          formatInfinity((range[1] ?? -Infinity) > start ? range[1] : start, infinityToNull),
          formatInfinity(tail, infinityToNull)
        ]);
      }
      return res.length ? [...acc, ...res] : acc;
    }, []),
    start,
    end,
    infinityToNull
  );
};

// src/urls/query-stringify/query-stringify.ts
var queryStringify = (object, prefix) => {
  if (isEmpty(object))
    return "";
  return tsObject.entries(object).reduce((acc, [key, value]) => {
    const encodedKey = encodeURIComponent(key);
    const pairKey = prefix ? `${prefix}[${encodedKey}]` : encodedKey;
    const pair = isPlainObject(value) || isArray(value) ? queryStringify(value, pairKey) : `${pairKey}=${encodeURIComponent(value)}`;
    acc.push(pair);
    return acc;
  }, []).filter(Boolean).join("&");
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  FORMAT_DATE_LOCALE_EN,
  FORMAT_DATE_LOCALE_RU,
  angle,
  arrayInsert,
  arrayInsertMutable,
  arrayOfLength,
  arrayRange,
  arrayRemove,
  arrayRemoveMutable,
  arraySample,
  arrayShuffle,
  arraySwap,
  arraySwapMutable,
  arrayUnique,
  arraysDifference,
  arraysIntersection,
  arraysUnion,
  assert,
  asyncArray,
  camelCase,
  capitalize,
  clamp,
  compose,
  configureAssert,
  createFormatDate,
  createMergeObjects,
  daysInMonth,
  debounce,
  deepClone,
  deepCloneStrict,
  deepEqual,
  deepEqualCircular,
  distance,
  escapeRegExp,
  fileExtension,
  formDataToObject,
  formatBytes,
  formatBytesRu,
  formatDate,
  formatDateEn,
  formatDateRu,
  formatSlashes,
  gcd,
  getDocumentSize,
  getElement,
  getElementOffset,
  getScrollLimit,
  getScrollableAncestor,
  getScrollbarWidth,
  getWindowScroll,
  hash,
  isArray,
  isBlob,
  isBoolean,
  isClient,
  isDate,
  isDev,
  isElement,
  isEmail,
  isEmpty,
  isError,
  isFile,
  isFirefox,
  isFloat,
  isFormData,
  isFunction,
  isHex,
  isInteger,
  isInternetExplorer,
  isIsoDate,
  isIterable,
  isLeapYear,
  isLighthouse,
  isLocalStorageAvailable,
  isMap,
  isMobile,
  isMotionless,
  isNode,
  isNull,
  isNullish,
  isNumeric,
  isOSX,
  isObject,
  isPlainObject,
  isPrimitive,
  isProd,
  isPromise,
  isRegExp,
  isServer,
  isSessionStorageAvailable,
  isString,
  isSymbol,
  isTest,
  isTouch,
  isUndefined,
  isWeakMap,
  kebabCase,
  lerp,
  mergeObjects,
  minTimePromise,
  noop,
  numberFormat,
  objectGet,
  objectKeysCase,
  objectToFormdata,
  omit,
  padEnd,
  padStart,
  parseDate,
  parseResponseCookie,
  pascalCase,
  pick,
  precision,
  promiseController,
  queryStringify,
  quote,
  randomDate,
  randomFloat,
  randomInteger,
  randomString,
  rangeIncludes,
  rangesCrop,
  rangesIntersection,
  rangesInvert,
  rangesMerge,
  rangesSort,
  romanize,
  safeJsonParse,
  serializeCookie,
  sleep,
  snakeCase,
  stripIndent,
  supportsPassive,
  throttle,
  toArray,
  toDate,
  toNumber,
  tsObject,
  unquote,
  verifyFileAccept,
  withProbability
});
