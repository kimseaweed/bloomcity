import { Primitive, Promisable, IntRange, JsonObject, IterableElement } from 'type-fest';
export { And, Includes as ArrayIncludes, ArrayIndices, ArraySlice, ArraySplice, ArrayValues, AsyncReturnType, Asyncify, Promisable as Awaitable, CamelCase, CamelCasedProperties, CamelCasedPropertiesDeep, Class, Constructor, DistributedOmit, DistributedPick, IterableElement as ElementOf, EmptyObject, Entries, Entry, Exact, Except, Simplify as Explicit, Finite, Float, Get, GlobalThis, GreaterThan, GreaterThanOrEqual, HasOptionalKeys, HasReadonlyKeys, HasRequiredKeys, HasWritableKeys, IfAny, IfEmptyObject, IfNever, IfUnknown, IntRange, Integer, InvariantOf, IsAny, IsBooleanLiteral, IsEmptyObject, IsEqual, IsFloat, IsInteger, IsLiteral, IsNegative, IsNever, IsNull, IsNumericLiteral, IsStringLiteral, IsSymbolLiteral, IsUnknown, Join, JsonArray, JsonObject, JsonPrimitive, JsonValue, Jsonifiable, Jsonify, KebabCase, KebabCasedProperties, KebabCasedPropertiesDeep, KeysOfUnion, LastArrayElement, LessThan, LessThanOrEqual, LiteralToPrimitive, LiteralToPrimitiveDeep, LiteralUnion, Sum as MathAdd, Subtract as MathSubtract, Merge, MergeDeep, MergeExclusive, MultidimensionalArray, MultidimensionalReadonlyArray, Negative, NegativeFloat, NegativeInfinity, NegativeInteger, NonEmptyObject, NonNegative, NonNegativeInteger, OmitDeep, OmitIndexSignature, Opaque, OptionalKeysOf, Or, OverrideProperties, PackageJson, PartialDeep, SetNonNullable as PartialNonNullable, PartialOnUndefinedDeep, SetOptional as PartialOptional, SetReadonly as PartialReadonly, SetRequired as PartialRequired, SetReturnType as PartialReturnType, PascalCase, PascalCasedProperties, PascalCasedPropertiesDeep, Paths, PickDeep, PickIndexSignature, PositiveInfinity, Primitive, ReadonlyDeep, ReadonlyKeysOf, ReadonlyTuple, RequireOneOrNone, RequiredDeep, RequiredKeysOf, Schema, SetFieldType, SetParameterType, SharedUnionFieldsDeep, SingleKeyObject, SnakeCase, SnakeCasedProperties, SnakeCasedPropertiesDeep, Split, Spread, StringKeyOf, Replace as StringReplace, StringSlice, Stringified, Tagged, TaggedUnion, TsConfigJson as TsConfig, TupleToUnion, TypedArray, UndefinedOnPartialDeep, UnionToIntersection, UnknownRecord, UnwrapOpaque, UnwrapTagged, ScreamingSnakeCase as UpperSnakeCase, ValueOf, Writable, WritableDeep, WritableKeysOf } from 'type-fest';
import { IncomingMessage } from 'node:http';
import { hash as hash$1 } from 'ohash';

/**
 * Mutable version of `arrayInsert()`.
 * Inserts an element(s) in a certain position of the given array. \
 * Mutates the original array.
 *
 * @param   arr     The original array.
 * @param   index   The needed index of newly added element(s).
 * @param   items   The item or items to insert.
 *
 * @returns         The array itself with inserted elements.
 */
declare const arrayInsertMutable: (arr: any[], index: number, ...items: any[]) => any[];
/**
 * Inserts an element(s) in a certain position of the given array. \
 * Doesn't mutate the original array.
 *
 * @param   arr     The original array.
 * @param   index   The needed index of newly added element(s).
 * @param   items   The item or items to insert.
 *
 * @returns         The whole new array with inserted elements.
 */
declare const arrayInsert: (arr: readonly any[], index: number, ...items: any[]) => any[];

/**
 * Constructs an array of a given length.
 * Kinda syntax sugar for `Array.from({ length: n })`.
 *
 * @param   length        The needed length of array.
 * @param   mapFunction   Optional function to return each element value.
 *
 * @returns               An array of a given length.
 */
declare const arrayOfLength: <T = undefined>(length: number, mapFunction?: (index: number) => T) => T[];

/**
 * Returns an array of integers starting from argument `from` and ending with `to` argument. \
 * Returns an array starting from / ending with `0` if single argument is passed.
 *
 * @param   from   Lower value of resulting array
 * @param   to     Upper value of resulting array
 *
 * @returns        An array starting with `from` and ending with `to`.
 */
declare const arrayRange: (from: number, to?: number) => number[];

/**
 * Mutable version of `arrayRemove()`.
 * Removes an element from a given array.
 *
 * @param   arr         The original array.
 * @param   value       The value to remove.
 * @param   onlyFirst   Whether to remove only first occurrence or all occurrences found.
 *                      Default is `false` that means to remove all occurrences.
 *
 * @returns             The array itself without specified elements.
 */
declare const arrayRemoveMutable: <T = any>(arr: T[], value: T, onlyFirst?: boolean) => T[];
/**
 * Removes an element from a given array. \
 * Doesn't mutate the original array.
 *
 * @param   arr         The original array.
 * @param   value       The value to remove.
 * @param   onlyFirst   Whether to remove only first occurrence or all occurrences found.
 *                      Default is `false` that means to remove all occurrences.
 *
 * @returns             The whole new array without specified elements.
 */
declare const arrayRemove: <T = any>(arr: readonly T[], value: T, onlyFirst?: boolean) => T[];

type NeverAsUndefined<Type, AsArray extends boolean> = [Type] extends [never] ? undefined : AsArray extends true ? Type[] : Type;
/**
 * Returns `size` random elements from the given array.
 *
 * @param   array      The original array.
 * @param   size       The needed length of sample. \
 *                     Default is `1`.
 * @param   oversize   Should the function return more elements than the original array has if `size` is greater than the original array length? \
 *                     Default is `false`.
 *
 * @returns            An array containing `size` elements from a given array,
 *                     or just a random value from the given array if the `size` is `1` (default).
 */
declare const arraySample: <const T, Size extends number = 1>(array: readonly T[], size?: Size, oversize?: boolean) => Size extends 1 ? NeverAsUndefined<T, false> : NeverAsUndefined<T, true>;

/**
 * Shuffles the given array.
 *
 * @param   array
 *
 * @returns         Shuffled array.
 */
declare const arrayShuffle: <T>(array: readonly T[]) => T[];

type SwapIndex = number | [number, number];
/**
 * Swaps array elements, or slices of its elements. \
 * **MUTATES** the given array.
 *
 * @param   arr              Array to operate with.
 * @param   firstPosition    Index of first element to swap (or a tuple from 2 numbers representing the array slice to swap).
 * @param   secondPosition   Index of seconde element to swap (or a tuple from 2 numbers representing the array slice to swap).
 *
 * @returns                  Array with swapped elements.
 *
 * @throws  Throws in case of invalid input:
 *          * If any swap position is outside of array range;
 *          * If swap ranges are crossed.
 */
declare const arraySwapMutable: <T>(arr: T[], firstPosition: SwapIndex, secondPosition: SwapIndex) => T[];
/**
 * Swaps array elements, or slices of its elements. \
 * **Does not mutate** the given array.
 *
 * @param   arr              Array to operate with.
 * @param   firstPosition    Index of first element to swap (or a tuple from 2 numbers representing the array slice to swap).
 * @param   secondPosition   Index of seconde element to swap (or a tuple from 2 numbers representing the array slice to swap).
 *
 * @returns                  Array with swapped elements.
 *
 * @throws  Throws in case of invalid input:
 *          * If any swap position is outside of array range;
 *          * If swap ranges are crossed.
 */
declare const arraySwap: <T>(arr: T[], firstPosition: SwapIndex, secondPosition: SwapIndex) => T[];

/**
 * Removes any duplicated values from given array.
 *
 * @example
 * arrayUnique([1, 2, 3, 4, 1, 2, 3]) -> [1, 2, 3, 4]
 *
 * @param   array
 *
 * @returns         Array without any duplicated values
 */
declare const arrayUnique: <T = any>(array: readonly T[]) => T[];

/**
 * Computes the symmetrical difference of passed arrays.
 *
 * @example
 * arraysDifference([1, 2, 3], [2, 3, 4]) -> [1, 4]
 *
 * @param   arrays   An arrays to process.
 *
 * @returns          An array containing all the unique values of each array.
 */
declare const arraysDifference: <T = any>(...arrays: readonly T[][]) => T[];

/**
 * Computes intersection of passed arrays.
 *
 * @example
 * arraysIntersection([1, 2, 3], [2, 3, 4]) -> [2, 3]
 * arraysIntersection([1, 2, 3], [2, 3, 4], [3, 4, 5]) -> [3]
 *
 * @param   arrays   Arrays to find intersection
 *
 * @returns          Intersection between arrays
 */
declare const arraysIntersection: <T = any>(...arrays: readonly T[][]) => T[];

/**
 * Computes the union of passed arrays.
 *
 * @example
 * arraysUnion([1, 2, 3], [3, 4, 5]) -> [1, 2, 3, 4, 5]
 *
 * @param   arrays   Arrays to process
 *
 * @returns          Union of arrays
 */
declare const arraysUnion: <T = any>(...arrays: readonly T[][]) => T[];

type Builtin = Primitive | Date | RegExp | Function | Error;

/**
 * Helper utility for exported `ArrayOf` type
 */
type CreateArrayOf<Quantifier extends 'exactly' | 'at least', Count extends number, Type, Current extends Type[]> = Current['length'] extends Count ? Quantifier extends 'exactly' ? [...Current] : [...Current, ...Type[]] : CreateArrayOf<Quantifier, Count, Type, [...Current, Type]>;
/**
 * An array of a given type comprised of either exactly
 * or at least a certain count of that type.
 */
type ArrayOf<Quantifier extends 'exactly' | 'at least', Count extends number, Type = any> = CreateArrayOf<Quantifier, Count, Type, []>;

/**
 * Non empty array
 */
type NonEmptyArray<T = any> = [T, ...T[]];

/**
 * A tuple containing `Count` elements of the type `Type`.
 */
type TupleOf<Count extends number, Type = any> = ArrayOf<'exactly', Count, Type>;

/**
 * Array, or not yet
 */
type Arrayable<T> = T | T[];

/**
 * Null or whatever
 */
type Nullable<T> = T | null;

/**
 * A cookie in object form.
 */
type Cookie = {
    /**
     * Cookie name.
     */
    name: string;
    /**
     * Cookie value.
     */
    value: string;
    /**
     * Cookie path.
     */
    path?: string;
    /**
     * Absolute expiration date for the cookie.
     */
    expires?: Date;
    /**
     * Relative max age of the cookie in seconds from when the client receives it (integer).
     * Note: when using with `express`'s `res.cookie()` method, multiply `maxAge` by 1000 to convert to milliseconds.
     */
    maxAge?: number;
    /**
     * Domain for the cookie.
     * May begin with "." to indicate the named domain or any subdomain of it.
     */
    domain?: string;
    /**
     * Indicates that this cookie should only be sent over HTTPs.
     */
    secure?: boolean;
    /**
     * Indicates that this cookie should not be accessible to client-side JavaScript.
     */
    httpOnly?: boolean;
    /**
     * Indicates that the cookie should be stored using partitioned storage.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/Privacy/Partitioned_cookies
     */
    partitioned?: boolean;
    /**
     * Indicates that this cookie should not be sent along with cross-site requests.
     *
     * @see https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value
     */
    sameSite?: 'Strict' | 'Lax' | 'None';
    /**
     * Allows servers to specify a retention priority for HTTP cookies
     * that will be respected by user agents during cookie eviction.
     *
     * @see https://datatracker.ietf.org/doc/html/draft-west-cookie-priority-00
     */
    priority?: 'Low' | 'Medium' | 'High';
    /**
     * For future extensions.
     */
    [key: string]: any;
};

/**
 * Object keys as an array. \
 * Suitable for typing `Object.keys()`
 */
type ObjectKeys<T extends object> = `${Exclude<keyof T, symbol>}`;

/**
 * Object entries. \
 * Suitable for typing `Object.entries()`
 */
type ObjectEntries<Type extends Record<PropertyKey, any>> = Array<[ObjectKeys<Type>, Type[ObjectKeys<Type>]]>;

/**
 * Object from entries. \
 * Suitable for typing `Object.fromEntries()`
 */
type ObjectFromEntries<Key extends PropertyKey, Entries extends ReadonlyArray<readonly [Key, any]>> = {
    [K in Extract<Entries[number], readonly [Key, any]>[0]]: Extract<Entries[number], readonly [K, any]>[1];
};

/**
 * Object values as an union with optional ability to set which keys should be presented.
 */
type ObjectValues<T extends Record<PropertyKey, any>, K extends keyof T = keyof T> = Array<T[K]>;

/**
 * Just an object.
 */
type PlainObject<T = any> = Record<string, T>;

/**
 * A string ending with another string.
 */
type EndsWith<Affix extends string = ''> = `${string}${Affix}`;

/**
 * A string starting with another string.
 */
type StartsWith<Affix extends string> = `${Affix}${string}`;

/**
 * Removes repeating `Character` from the right side of given `Input`.
 */
type TrimEnd<Input extends string, Character extends string = ' '> = Input extends `${infer R}${Character}` ? TrimEnd<R, Character> : Input;

/**
 * Removes repeating `Character` from the left side of given `Input`
 */
type TrimStart<Input extends string, Character extends string = ' '> = Input extends `${Character}${infer R}` ? TrimStart<R, Character> : Input;

/**
 * Removes repeating `Character` from left and right side of given `Input`.
 */
type Trim<Input extends string, Character extends string = ' '> = TrimStart<TrimEnd<Input, Character>, Character>;

interface AsyncArray<T> {
    /**
     * Performs the specified action for each element in an array.
     *
     * @param   callbackfn   A function that accepts up to three arguments. \
     *                       `forEach` calls the `callbackfn` function one time for each element in the array.
     * @param   thisArg      An object to which the `this` keyword can refer in the `callbackfn` function.
     *                       If thisArg is omitted, `undefined` is used as the `this` value.
     */
    forEach(callbackfn: (value: Awaited<T>, index: number, array: Array<Awaited<T>>) => void, thisArg?: any): Promise<void>;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     *
     * @param   callbackfn   A function that accepts up to three arguments. \
     *                       The map method calls the callbackfn function one time for each element in the array.
     * @param   thisArg      An object to which the this keyword can refer in the callbackfn function. \
     *                       If thisArg is omitted, `undefined` is used as the `this` value.
     */
    map<U>(callbackfn: (value: Awaited<T>, index: number, array: Array<Awaited<T>>) => Promisable<U>, thisArg?: any): Promise<Array<Awaited<U>>>;
    /**
     * Calls the specified callback function for all the elements in an array. \
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param   callbackfn     A function that accepts up to four arguments. \
     *                         The reduce method calls the callbackfn function one time for each element in the array.
     * @param   initialValue   If initialValue is specified, it is used as the initial value to start the accumulation. \
     *                         The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce(callbackfn: (previousValue: Awaited<T>, currentValue: Awaited<T>, currentIndex: number, array: Array<Awaited<T>>) => Promisable<T>, initialValue?: T): Promise<Awaited<T>>;
    /**
     * Calls the specified callback function for all the elements in an array. \
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param   callbackfn     A function that accepts up to four arguments. \
     *                         The reduce method calls the callbackfn function one time for each element in the array.
     * @param   initialValue   If initialValue is specified, it is used as the initial value to start the accumulation. \
     *                         The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduce<U>(callbackfn: (previousValue: Awaited<U>, currentValue: Awaited<T>, currentIndex: number, array: Array<Awaited<T>>) => Promisable<U>, initialValue: U): Promise<Awaited<U>>;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. \
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param   callbackfn     A function that accepts up to four arguments. \
     *                         The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param   initialValue   If initialValue is specified, it is used as the initial value to start the accumulation. \
     *                         The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight(callbackfn: (previousValue: Awaited<T>, currentValue: Awaited<T>, currentIndex: number, array: Array<Awaited<T>>) => Promisable<T>, initialValue?: T): Promise<Awaited<T>>;
    /**
     * Calls the specified callback function for all the elements in an array, in descending order. \
     * The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     *
     * @param   callbackfn     A function that accepts up to four arguments. \
     *                         The reduceRight method calls the callbackfn function one time for each element in the array.
     * @param   initialValue   If initialValue is specified, it is used as the initial value to start the accumulation. \
     *                         The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    reduceRight<U>(callbackfn: (previousValue: Awaited<U>, currentValue: Awaited<T>, currentIndex: number, array: Array<Awaited<T>>) => Promisable<U>, initialValue: U): Promise<Awaited<U>>;
}

/**
 * A wrapper over some `Array` methods to use asynchronous functions in an intuitive way.
 *
 * @param   arr   Array of promises or values to iterate over.
 *
 * @returns       `AsyncArray` instance.
 */
declare const asyncArray: <T>(arr: T[]) => AsyncArray<T>;

type ToReturn$6<T> = T extends any[] ? T : T[];
/**
 * Casts the given value to an array.
 * Remains array as is if given value is an array already.
 *
 * @param   value   Any value to test.
 *
 * @returns         Array itself if the value is already an array, single-value array containing value otherwise.
 */
declare const toArray: <T>(value: T) => ToReturn$6<T>;

type Options$c = {
    /**
     * Whether to call `decodeURIComponent` for each value.
     *
     * @default true
     */
    decodeValues: boolean;
    /**
     * Return value format.
     *
     * @default 'array'
     */
    returnType: 'array' | 'object';
};
type CookieMap = Record<string, Cookie>;
type ToReturn$5<UserOptions extends Partial<Options$c> | undefined> = UserOptions extends Partial<Options$c> ? UserOptions['returnType'] extends string ? UserOptions['returnType'] extends 'object' ? CookieMap : Cookie[] : Cookie[] : Cookie[];
/**
 * Parses a cookie header into `Cookie` objects.
 *
 * @param   input         A string containing the cookie header, an array of such strings or fetch `Response` object.
 * @param   userOptions   Parser options.
 *
 * @returns               Array of parsed cookie objects or object containing cookie name
 *                        as a key and cookie object as a value depending on `userOptions.returnType` property.
 */
declare const parseResponseCookie: <UserOptions extends Partial<Options$c> = Options$c>(input: string | string[] | Response | IncomingMessage | undefined | null, userOptions?: UserOptions) => ToReturn$5<UserOptions>;

type Options$b = {
    /**
     * Whether the cookie value should be encoded using `encodeURIComponent`.
     *
     * @default true
     */
    encodeValue: boolean;
};
/**
 * Serializes a Cookie object into cookie string.
 *
 * @param   cookie        Object representing a cookie.
 * @param   userOptions   Serialization options.
 *
 * @returns               A cookie string.
 */
declare const serializeCookie: (cookie: Cookie, userOptions?: Partial<Options$b>) => string;

/**
 * Retrieves count of days in given `month` and `year`. \
 * Uses local time year if no `year` argument is passed.
 *
 * @param   monthIndex   Index of month (January is 0)
 * @param   year         Year (uses local time year if omitted)
 *
 * @returns              Count of days in given month for year `year` (or local year)
 */
declare const daysInMonth: (monthIndex: number, year?: number) => number;

type Input$1 = Date | string | number;
type Options$a = {
    /**
     * Whether to construct the string using value as UTC.
     *
     * @default false
     */
    utc: boolean;
    /**
     * A locale to use.
     */
    locale: string;
};
type LocaleObject = {
    /**
     * Locale name.
     */
    name: string;
    /**
     * Locale-specific values.
     */
    values: {
        /**
         * First day of the week relative to Sunday, e.g.
         * `0`, if the first day of the week is Sunday,
         * `1` if the first day of the week is Monday, etc.
         */
        firstDayOfWeekIndex: IntRange<0, 6>;
        /**
         * Locale-specific day names.
         */
        dayNames: {
            /**
             * Abbreviated day names in order started with Sunday day, e.g. `['Sun', 'Mon', ...]`
             */
            abbreviated: ArrayOf<'exactly', 7, string>;
            /**
             * Wide (full) day names in order started with Sunday day, e.g. `['Sunday', 'Monday', ...]`
             */
            wide: ArrayOf<'exactly', 7, string> | ArrayOf<'exactly', 7, [string, string]>;
        };
        /**
         * Locale-specific month names.
         */
        monthNames: {
            /**
             * Abbreviated month names in order started with January day, e.g. `['Jan', 'Feb', ...]`
             */
            abbreviated: ArrayOf<'exactly', 12, string>;
            /**
             * Wide (full) month names in order started with January day, e.g. `['January', 'February', ...]`
             */
            wide: ArrayOf<'exactly', 12, string> | ArrayOf<'exactly', 12, [string, string]>;
        };
    };
};
interface FormatDate {
    /**
     * Formats a given Date, timestamp or a date in string form (can be represented as ISO, in Russin or British notation)
     * according to a given pattern.
     *
     * @see https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     *
     * @param   pattern   A pattern to format the date with. \
     *                    The list of tokens is taken from https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table, but is incomplete.
     *
     *                    To preserve the string as it is, enclose it in square brackets, e.g. `formatDate('[The date is] MM/dd/yyyy')`
     *
     *                    **Available tokens (summary)**:
     *                    * `year`: `yy`, `yyyy`
     *                    * `month (standalone)`: `L`, `LL`, `LLL`, `LLLL`, `_LLL`, `_LLLL`
     *                    * `month (format)`: `M`, `MM`, `MMM`, `MMMM`, `_MMM`, `_MMMM`
     *                    * `weekday (standalone)`: `c`, `cc`, `ccc`, `cccc`, `_ccc`, `_cccc`
     *                    * `weekday (format)`: `e`, `ee`, `eee`, `eeee`, `_eee`, `_eeee`
     *                    * `day`: `d`, `dd`
     *                    * `hours`: `h`, `hh`, `H`, `HH`
     *                    * `minutes`: `m`, `mm`
     *                    * `seconds`: `s`, `ss`
     *                    * `timezone`: `X`, `XX`, `XXX`
     *
     *                    **Available tokens (in details)**:
     *                    * `-- Year -- `
     *                    * `yy` - last two digits of the year, e.g. "14" for "2014", "94" for "1994", etc
     *                    * `yyyy` - full year, e.g. "2014" or "2014"
     *
     *                    * `-- Month (standalone style) -- `
     *                    * `L` - standalone numeric month (stated with 1) with minimal required digits, e.g. "1", "12"
     *                    * `LL` - standalone padded numeric month (stated with 1), e.g. "01", "12"
     *                    * `LLL` - standalone abbreviated month name, e.g. "Jan", "Aug"
     *                    * `_LLL` - lowercased standalone abbreviated month name, e.g. "jan", "aug"
     *                    * `LLLL` - standalone wide month name, e.g. "January", "August"
     *                    * `_LLLL` - lowercased standalone abbreviated month name, e.g. "january", "august"
     *
     *                    * `-- Month (format style) -- `
     *                    * `M` - formatted numeric month (stated with 1) with minimal required digits, e.g. "1", "12"
     *                    * `MM` - formatted padded numeric month (stated with 1), e.g. "01", "12"
     *                    * `MMM` - formatted abbreviated month name, e.g. "Jan", "Aug"
     *                    * `_MMM` - lowercased formatted abbreviated month name, e.g. "jan", "aug"
     *                    * `MMMM` - formatted wide month name, e.g. "January", "August"
     *                    * `_MMMM` - lowercased formatted abbreviated month name, e.g. "january", "august
     *                    "
     *                    * `-- Weekday (standalone style) -- `
     *                    * `c` - standalone numeric weekday index (stated with 1) with minimal required digits, e.g. "1", "7"
     *                    * `cc` - standalone padded numeric weekday index (stated with 1), e.g. "01", "07"
     *                    * `ccc` - standalone abbreviated weekday name, e.g. "Mon", "Tue"
     *                    * `_ccc` - lowercased standalone abbreviated weekday name, e.g. "mon", "tue"
     *                    * `cccc` - standalone wide weekday name, e.g. "Monday", "Tuesday"
     *                    * `_cccc` - lowercased standalone abbreviated weekday name, e.g. "monday", "tuesday"
     *
     *                    * `-- Weekday (format style) -- `
     *                    * `e` - formatted numeric weekday index (stated with 1) with minimal required digits, e.g. "1", "12"
     *                    * `ee` - formatted padded local weekday index (stated with 1), e.g. "01", "12"
     *                    * `eee` - formatted abbreviated weekday name, e.g. "Mon", "Tue"
     *                    * `_eee` - lowercased formatted abbreviated weekday name, e.g. "mon", "tue"
     *                    * `eeee` - formatted wide weekday name, e.g. "Monday", "Tuesday"
     *                    * `_eeee` - lowercased formatted abbreviated weekday name, e.g. "monday", "tuesday"
     *
     *                    * `-- Day -- `
     *                    * `d` - index of the day in the month (stated with 1) with minimal required digits, e.g. "1", "25"
     *                    * `dd` - padded index of the day in the month (stated with 1), e.g. "01", "25"
     *
     *                    * `-- Hours -- `
     *                    * `h` - hours in range [0..11] with minimal required digits, e.g. "1", "10"
     *                    * `hh` - padded hours in range [0..11], e.g. "01", "10"
     *                    * `H` - hours in range [0..23] with minimal required digits, e.g. "1", "23"
     *                    * `HH` - padded hours in range [0..23], e.g. "01", "10"
     *
     *                    * `-- Minutes -- `
     *                    * `m` - minutes with minimal required digits, e.g. "1", "53"
     *                    * `mm` - padded minutes, e.g. "01", "54"
     *
     *                    * `-- Seconds -- `
     *                    * `s` - seconds with minimal required digits, e.g. "1", "53"
     *                    * `ss` - padded seconds, e.g. "01", "54"
     *
     *                    * `-- Timezone -- `
     *                    * `X` - ISO8601-compatible timezone with minimal characters, e.g. "Z", "-03", "-0300"
     *                    * `XX` - ISO8601-compatible timezone in basic form, e.g. "Z", "-0300", "+0300"
     *                    * `XXX` - ISO8601-compatible timezone in extended form, e.g. "Z", "-03:00", "+03:00"
     * @param   input     A Date object, timestamp or string form of the date (in ISO8601, Russian or British notation).
     * @param   options   Formatter options.
     *
     * @returns           A string built from the date according to the pattern and options, or `null` in case of invalid input.
     */
    (pattern: string, input: Input$1, options?: Partial<Options$a>): string | null;
}

/**
 * Creates a date format function.
 *
 * @param   localeData       Locale data.
 * @param   defaultOptions   An options passed to format function as defaults.
 *
 * @returns                  Date format function with defined locales.
 */
declare const createFormatDate: (localeData: Arrayable<LocaleObject>, defaultOptions: Options$a) => FormatDate;
declare const formatDate: FormatDate;
declare const formatDateRu: FormatDate;
declare const formatDateEn: FormatDate;

declare const FORMAT_DATE_LOCALE_EN: LocaleObject;
declare const FORMAT_DATE_LOCALE_RU: LocaleObject;

/**
 * Checks whether the given value is a valid ISO date string.
 *
 * @param   input    Value being evaluated.
 * @param   strict   Whether the date should be checked for validity in addition to checking just the syntax.
 *                   This includes checking for leap years and invalid dates like "April 31" (there are only 30 days in April)
 *
 * @returns          Whether the value is a valid ISO date string.
 */
declare const isIsoDate: (input: unknown, strict?: boolean) => input is string;

/**
 * Checks whether the passed value is a Date representing or leap year,
 * or whether the passed number (or string representation of a number)
 * is a representation of a leap year.
 *
 * @param   value   The value to check.
 *
 * @returns         Whether the value represents a leap year.
 */
declare const isLeapYear: (value: string | number | Date) => boolean;

type _DateTokens = {
    /**
     * Year of the date.
     */
    year: number;
    /**
     * Index of index of the date in range `[0..11]`.
     */
    month: number;
    /**
     * Day of the month of the date in range `[0..28|29|30|31]` depending on month and leap year.
     */
    day: number;
    /**
     * Hour of the date in range `[0..23]`.
     */
    hours: number;
    /**
     * Minutes of the date in range `[0..59]`.
     */
    minutes: number;
    /**
     * Seconds of the date in range `[0..59]`.
     */
    seconds: number;
    /**
     * Milliseconds of the date in range `[0..999]`.
     */
    milliseconds: number;
    /**
     * An offset to apply to correct the timezone in minutes.
     */
    offset?: number;
};
type DateTokens = Omit<_DateTokens, 'offset'>;

type Options$9 = {
    /**
     * Whether to treat the passed value as a UTC datetime.
     *
     * @default false
     */
    utc: boolean;
};
/**
 * Splits a given Date / date string in various syntax / timestamp into a separate tokens. \
 * The tokens are always refer to a local date, `utc` option controls how to treat the given value.
 *
 * @param   input         A Date object, or a date string written in ISO, Russian or British notation, or a timestamp.
 *                        Example of ISO string: `2024-05-25T23:00:00+0030` \
 *                        Example of date string in Russian notation: `25.05.2024 23:00:00` \
 *                        Example of date string in British notation: `05/25/2024 23:00:00`
 * @param   userOptions   Parser options.
 *
 * @returns               Date tokens or `null` in case of invalid input.
 */
declare const parseDate: (input: string | number | Date, userOptions?: Partial<Options$9>) => DateTokens | null;

type Options$8 = {
    /**
     * The time to be set for the date.
     * Can be a tuple of numbers of length from 1 to 4 in the order `[hours, minutes?, seconds?, milliseconds?]`
     * or a string in the format `hh:mm:ss.mmm`.
     */
    time: [number] | [number, number] | [number, number, number] | [number, number, number, number] | string;
};
/**
 * Generates a random date between `start` and `end` dates. \
 * Optionally can set specific time for a date using `time` option.
 *
 * @param   start         Minimum date. Default is a Date object for a date `01.01.1970`.
 * @param   end           Maximum date. Default is the current date.
 * @param   userOptions   Generation options.
 *
 * @returns               A random date between `start` and `end` date with (optionally) set time.
 */
declare const randomDate: (start?: Date | null, end?: Date | null, userOptions?: Partial<Options$8>) => Date;

type Options$7 = {
    /**
     * Whether to treat the passed value as UTC.
     *
     * @default false
     */
    utc: boolean;
};
/**
 * Attempts to convert a given value to a Date object. \
 * The value can be a Date (it's guaranteed that if it was returned, the Date is valid),
 * ISO-compatible string or a date string written in Russian or British notation.
 *
 * Return value is always adjusted to a local time, option `utc` controls how to treat the input value.
 *
 * @param   value         Timestamp, Date object, ISO-compatible string
 *                        or a string with date in Russian or British notation.
 * @param   userOptions   Transforming options.
 *
 * @returns               A Date object or `null` in case of invalid input.
 */
declare const toDate: (value: string | number | Date, userOptions?: Options$7) => Date | null;

type Axis$4 = 'x' | 'y' | 'both';
type ToReturn$4<T> = T extends 'both' ? {
    x: number;
    y: number;
} : number;
/**
 * Retrieves the document scroll size (width, height or both).
 *
 * @param   [axis]   Whether to return the document scroll width (x) or height (y), or both.
 *
 * @returns          The document scroll size in defined axis or both.
 */
declare const getDocumentSize: <T extends Axis$4>(axis?: T) => ToReturn$4<T>;

/**
 * Retrieves the Element by a given selector using optional parent element,
 * or just returns a given element as is.
 *
 * @param   value    Queried element selector or the element itself.
 * @param   parent   The parent element within which to search.
 *
 * @returns          The element being queried or `null` if does not exists.
 */
declare const getElement: <El extends Element = Element>(value: Element | string | null, parent?: Window | Element | string | null) => El | null;

type Axis$3 = 'x' | 'y' | 'both';
type ToReturn$3<T> = T extends 'both' ? {
    x: number;
    y: number;
} : number;
/**
 * Retrieves the element offset from given ancestor.
 *
 * @param   el       Element
 * @param   axis     Retrieve only `x` or `y` offset, or both
 * @param   parent   Parent element, default is `window`
 *
 * @returns          The element offset
 */
declare const getElementOffset: <T extends Axis$3>(el: Element, axis?: T, parent?: Element | Window | null) => ToReturn$3<T>;

type Axis$2 = 'x' | 'y' | 'both';
type ToReturn$2<T> = T extends 'both' ? {
    x: number;
    y: number;
} : number;
/**
 * Retrieves the maximum scroll value.
 *
 * @param   [axis]   Scroll axis (x | y | both).
 *
 * @returns          The maximum scroll value by a given axis or both (default is 'y').
 */
declare const getScrollLimit: <T extends Axis$2>(axis?: T) => ToReturn$2<T>;

type Axis$1 = 'x' | 'y' | 'both';
/**
 * Retrieves the nearest scrollable ancestor element of a given element.
 *
 * @param   element   The element being evaluated.
 * @param   axis      Consider only one axis (`x`, `y`) or both
 *
 * @returns           The nearest scrollable ancestor element of a given element, or the `window` object.
 */
declare const getScrollableAncestor: <El extends Element = Element>(element: Element | null, axis?: Axis$1) => El | Window;

/**
 * Retrieves scrollbar width of element with body as default.
 *
 * @param   el   Element to retrieve its scrollbar width.
 *
 * @returns      Scrollbar width in `px`.
 */
declare const getScrollbarWidth: (el?: HTMLElement) => number;

type Axis = 'x' | 'y' | 'both';
type ToReturn$1<T extends Axis> = T extends 'both' ? {
    x: number;
    y: number;
} : number;
/**
 * Retrieves the window scroll value for given axis, or both
 *
 * @param   axis   Axis to restrict return value
 *
 * @returns        Window scroll for given axis or both (default is 'y')
 */
declare const getWindowScroll: <T extends Axis>(axis?: T) => ToReturn$1<T>;

/**
 * Checks if the code is running on the client side.
 *
 * @returns   Whether a browser is being used for execution
 */
declare const isClient: () => boolean;

/**
 * Checks whether the application runs in development mode.
 *
 * @returns   Whether the application runs in development node.
 */
declare const isDev: () => boolean | null;

/**
 * Checks if a Firefox browser is being used.
 *
 * @returns   Whether Firefox browser is being used.
 */
declare const isFirefox: () => boolean;

/**
 * Checks if a legacy Internet Explorer browser (IE <= 11) is being used.
 *
 * @returns   Whether legacy IE browser (<= 11) is being used.
 */
declare const isInternetExplorer: () => boolean;

/**
 * Checks if a Lighthouse user agent is being used. \
 * I condemn the use, but it is difficult to explain to customers.
 *
 * @returns   Whether the browser with Lighthouse user agent is being used.
 */
declare const isLighthouse: (userAgent?: string) => boolean;

/**
 * Checks if a mobile browser is being used.
 *
 * @returns   Whether any mobile browser is being used.
 */
declare const isMobile: () => boolean;

/**
 * Checks whether the user has requested the operating system
 * to minimize the amount of animation or motion it uses.
 *
 * @returns   Whether user prefer to reduce motion
 */
declare const isMotionless: () => boolean;

/**
 * Checks if an Apple device is being used.
 *
 * @returns   Whether any Apply device is being used
 */
declare const isOSX: () => boolean;

/**
 * Checks whether the application runs in production mode.
 *
 * @returns   Whether the application runs in production node.
 */
declare const isProd: () => boolean | null;

/**
 * Checks if the code is running on the server side (outside the browser context)
 *
 * @returns   Whether a server environment is being used for execution
 */
declare const isServer: () => boolean;

/**
 * Checks whether the application runs in testing mode.
 *
 * @returns   Whether the application runs in testing node.
 */
declare const isTest: () => boolean;

/**
 * Checks whether the current browser runs on a touch device.
 *
 * @returns   Whether any touch device is being used
 */
declare const isTouch: () => boolean;

/**
 * Checks whether the current browser supports passive event listeners.
 *
 * @returns   Whether the browser supports passive events
 */
declare const supportsPassive: () => boolean;

/**
 * Properties that are passed (or executed and then passed) to reporters and Error.
 */
type Properties = JsonObject | (() => JsonObject);
/**
 * Failure type depending on the type of the first argument.
 */
type FailureType = 'condition' | 'no-value';
/**
 * The function that formats an error.
 *
 * @param   failureType   The failure type: `condition` or `no-value`.
 * @param   message       The custom message provided by developer.
 * @param   properties    The custom properties provided by developer.
 *
 * @returns               Formatted string message.
 */
type ErrorFormatter = (failureType: FailureType, message?: string, properties?: JsonObject) => string;
/**
 * The function that creates an Error object depending on given arguments.
 *
 * @param   failureType   The failure type: `condition` or `no-value`.
 * @param   message       The custom message provided by developer.
 * @param   properties    The custom properties provided by developer.
 *
 * @returns               Error instance to be thrown.
 */
type ErrorCreator = (failureType: FailureType, message?: string, properties?: JsonObject) => Error;
/**
 * The function that executes user-defined logic
 * depending on the given arguments before Error is thrown.
 *
 * @param   failureType   The failure type: `condition` or `no-value`.
 * @param   message       The custom message provided by developer.
 * @param   properties    The custom properties provided by developer.
 */
type ErrorReporter = (failureType: FailureType, error: Error, message?: string, properties?: JsonObject) => void;
/**
 * The function that executes user-defined logic depending on the given arguments
 * using `.soft()` version of `assert` if it fails.
 *
 * @param   failureType   The failure type: `condition` or `no-value`.
 * @param   message       The custom message provided by developer.
 * @param   properties    The custom properties provided by developer.
 */
type WarningReporter = (failureType: FailureType, message?: string, properties?: JsonObject) => void;
/**
 * Configuration of `assert` method.
 */
type AssertConfiguration = {
    formatter?: ErrorFormatter;
    errorCreator?: ErrorCreator;
    errorReporter?: ErrorReporter;
    warningReporter?: WarningReporter;
};
interface HardAssert {
    /**
     * Verifies that the condition is satisfied.
     *
     * @param   condition    Condition to be true.
     * @param   message      The custom message provided by developer.
     * @param   properties   The custom properties provided by developer.
     *
     * @throws Throws exception if condition is `false`.
     */
    (condition: boolean, message?: string, properties?: Properties): asserts condition;
    /**
     * Verifies that the given value is not `null` or `undefined`.
     *
     * @param   value        Value to be verified.
     * @param   message      The custom message provided by developer.
     * @param   properties   The custom properties provided by developer.
     *
     * @throws Throws exception if value is `null` or `undefined`.
     */
    <T>(value: T | boolean | undefined | null, message?: string, properties?: Properties): asserts value is T;
}
interface SoftAssert {
    /**
     * Test if the condition is satisfied. \
     * If `false`, a warning will be reported.
     *
     * @param   condition    Condition to be `true`.
     * @param   message      The custom message provided by developer.
     * @param   properties   The custom properties provided by developer.
     *
     * @returns              Boolean representing condition.
     */
    (condition: boolean, message?: string, properties?: Properties): condition is true;
    /**
     * Test if the given value is not `null` or `undefined`. \
     * If value is `null` or `undefined`, a warning will be reported.
     *
     * @param   value        Value to test.
     * @param   message      The custom message provided by developer.
     * @param   properties   The custom properties provided by developer.
     *
     * @throws Throws exception if value is `null` or `undefined`.
     */
    <T>(value: T | boolean | undefined | null, message?: string, properties?: Properties): value is T;
}
interface Assert extends HardAssert {
    /**
     * The version of `assert` utility that doesn't throw an Error.
     */
    soft: SoftAssert;
}

declare const assert: Assert;
/**
 * The function that allows to redeclare one or many configuration options.
 *
 * @param   customConfiguration   The custom configuration to use.
 */
declare const configureAssert: (customConfiguration: AssertConfiguration) => void;

/**
 * A very simple alternative of `pipeline operator` working with single return value
 *
 * @see https://github.com/tc39/proposal-pipeline-operator
 *
 * @example
 * const func1 = (v) => v + '-baz';
 * const func2 = (v) => v + '-bar';
 *
 * compose(func1, func2)('foo') -> func1(func2('foo')) -> 'foo-bar-baz'
 *
 * @param   functions   Functions to proccess value with.
 *
 * @returns             Composed function
 */
declare const compose: (...functions: readonly Function[]) => any;

/**
 * Delays a given function invoking until a given `delay` time have elapsed since the last time a function was invoked.
 *
 * @param   fn          A function being invoked.
 * @param   delay       Timeout between function invoking, ms.
 * @param   immediate   Whether to invoke a given function immediately after initialization.
 *
 * @returns             Debounced function
 */
declare const debounce: <F extends (...args: any[]) => any>(fn: F, delay?: number, immediate?: boolean) => (...args: Parameters<F>) => ReturnType<F>;

type HashOptions = Parameters<typeof hash$1>[1];
/**
 * Hashes any JS value into a string.
 *
 * @param   value     The value to hash.
 * @param   options   Hashing options.
 *
 * @returns           Hash string for a given value.
 */
declare const hash: (value: unknown, options?: HashOptions) => string;

/**
 * Does nothing.
 *
 * @returns   {void}   Nothing
 */
declare const noop: Function;

type Reviver = Parameters<typeof JSON.parse>[1];
/**
 * `JSON.parse()` which does not throw, returning `null` instead if an error occurs.
 * This reduces verbosity due to the missing `try..catch` block,
 * also allowing a default value to be set in case of an invalid JSON string.
 *
 * NOTE: Although `JSON.parse()` allows some literals (such as numbers or boolean values) to act as arguments,
 * this feels wrong - we usually want an object or array as a result of parsing.
 * This function immediately returns `null` in case of non-string input.
 *
 * @example
 * type ResultType = {
 *   isAuthorized: true;
 *   username: string;
 * } | {
 *   isAuthorized: false;
 *   username: null;
 * };
 *
 * const defaultValue: ResultType = { isAuthorized: false, username: null }
 *
 * // `result` is typed as `ResultType` with the default value in case of an error just in one line.
 * const result = <ResultType>safeJsonParse(jsonString) ?? defaultValue;
 *
 * @param   jsonString   A string representing JSON value.
 * @param   reviver      A function that transforms the results. \
 *                       This function is called for each member of the object. \
 *                       If a member contains nested objects, the nested objects are transformed before the parent object is.
 *
 * @returns
 */
declare const safeJsonParse: <ReturnType = any>(jsonString: unknown, reviver?: Reviver) => ReturnType | null;

/**
 * Exposes a simple way to make the delay via Promise.
 *
 * @param   duration   Duration of delay (ms)
 *
 * @returns            Nothing.
 */
declare const sleep: (duration?: number) => Promise<void>;

type Options$6 = {
    delay: number;
    leading?: boolean;
    trailing?: boolean;
};
declare const throttle: (callback: Function, optionsOrDelay?: Options$6 | number) => {
    (...args: any[]): void;
    cancel: () => void;
};

/**
 * Checks the file against `accept` string as `<input type="file" />` does.
 * The OS will prevent you from selecting a file that does not satisfy the `accept` string,
 * but this doesn't happen for files you drag&drop to the field directly,
 * so files received after the `drop` event should be filtered against `accept` string manually.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/accept
 *
 * @param   file     A file to validate against given `accept` string.
 * @param   accept   The same string as the one passed to the `accept` attribute of the `<input type="file" />`
 *
 * @returns          Whether the file satisfies the given `accept' string.
 */
declare const verifyFileAccept: (file: File, accept: string | undefined | null) => boolean;

type ReturnValue<Value> = Value extends ((...args: any[]) => any) ? ReturnType<Value> : Value;
/**
 * Function for obtaining a value with a certain probability.
 * It is used primarily in the generation of mock data.
 *
 * @example
 * const discount = withProbability(.8, 0, () => randomInteger(200, 1000))
 *
 * @param   probability      Probability that `primaryValue` will be returned.
 * @param   primaryValue     A primary value.
 * @param   secondaryValue   A secondary value.
 *
 * @returns                  The primary value with the given probability, otherwise secondary value.
 */
declare const withProbability: <A, B>(probability: number | string, primaryValue: A, secondaryValue: B) => ReturnValue<A> | ReturnValue<B>;

/**
 * Checks whether a given value is an array.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is Array
 */
declare const isArray: <T = any>(value: unknown) => value is T[];

/**
 * Checks whether a given value is `Blob`.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is `Blob`.
 */
declare const isBlob: (value: unknown) => value is Blob;

/**
 * Checks whether a given value is a boolean.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is Boolean
 */
declare const isBoolean: (value: unknown) => value is boolean;

/**
 * Checks whether a given value is a date object.
 * Optionally it can also check whether the given value represents a valid date.
 *
 * @param   value           The value being evaluated.
 * @param   checkValidity   Whether to return `false` if the Date object is invalid, e.g. `new Date('foo')`.
 *
 * @returns                 Whether the value is Date object. \
 *                          If the second argument is `true` it returns `false` for invalid Date objects.
 */
declare const isDate: (value: unknown, checkValidity?: boolean) => value is Date;

/**
 * Checks whether a given value is a DOM Element.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is DOM Element
 */
declare const isElement: (value: unknown) => value is Element;

/**
 * Checks whether a given string is a valid email.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is a valid email address.
 */
declare const isEmail: (value: unknown) => value is string;

/**
 * Checks whether a given value is considered to be empty.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is `empty`.
 */

type Empty = undefined | null | false | 0 | 0n | '' | readonly [] | [] | PlainObject<never>;
declare const isEmpty: (value: unknown) => value is Empty;

/**
 * Checks whether a given value is a `Error`.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is a `Error`.
 */
declare const isError: (value: unknown) => value is Error;

/**
 * Checks whether a given value is `File`.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is `File`.
 */
declare const isFile: (value: unknown) => value is File;

/**
 * Checks whether a given value is a float number.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is float number
 */
declare const isFloat: (value: unknown) => value is bigint;

/**
 * Checks whether a given value is a FormData object.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is FormData instance
 */
declare const isFormData: (value: unknown) => value is FormData;

/**
 * Checks whether a given value is a function.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is Function
 */
declare const isFunction: (value: unknown) => value is Function;

/**
 * Checks whether a given value is a valid HEX.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is a valid HEX.
 */
declare const isHex: (value: unknown) => value is string;

/**
 * Checks whether a given value is an integer number.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is integer number
 */
declare const isInteger: (value: unknown) => value is number;

/**
 * Checks whether a given value is iterable.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is `Iterable`.
 */
declare const isIterable: (value: unknown) => value is Iterable<any>;

/**
 * Checks whether `localStorage` is available.
 *
 * @returns   Whether `localStorage` is available.
 */
declare const isLocalStorageAvailable: () => boolean;

/**
 * Checks whether the given value is a Map.
 * Note: this might not work when performed in a different window context.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the given value is a Map or not.
 */
declare const isMap: (value: unknown) => value is Map<any, any>;

/**
 * Checks whether a given value is a Node.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is a Node
 */
declare const isNode: (value: unknown) => value is Node;

/**
 * Checks whether a given value is `null`.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is `null`.
 */
declare const isNull: (value: unknown) => value is null;

/**
 * Checks whether a given value is considered to be nullish.
 *
 * @see      https://developer.mozilla.org/en-US/docs/Glossary/Nullish
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is nullish value
 */
declare const isNullish: (value: unknown) => value is null | undefined;

/**
 * Checks whether a given value is a valid number.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is a valid number
 */
declare const isNumeric: (value: unknown) => value is number;

/**
 * Checks whether a given value is an object.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is an Object.
 */
declare const isObject: (value: unknown) => value is Record<string, unknown>;

/**
 * Checks whether a given value is a plain object.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is a plain object.
 */
declare const isPlainObject: (value: unknown) => value is PlainObject<unknown>;

/**
 * Checks whether the value is a primitive.
 *
 * @see https://developer.mozilla.org/en-US/docs/Glossary/Primitive
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is a primitive value.
 */
declare const isPrimitive: (value: unknown) => value is Primitive;

/**
 * Checks whether a given value is a Promise.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is Promise
 */
declare const isPromise: (value: unknown) => value is Promise<any>;

/**
 * Checks whether a given value is an instance of RegExp.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is RegExp
 */
declare const isRegExp: (value: unknown) => value is RegExp;

/**
 * Checks whether `sessionStorage` is available.
 *
 * @returns   Whether `sessionStorage` is available.
 */
declare const isSessionStorageAvailable: () => boolean;

/**
 * Checks whether a given value is a string.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is String
 */
declare const isString: (value: unknown) => value is string;

/**
 * Checks whether a given value is a symbol.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is symbol.
 */
declare const isSymbol: (value: unknown) => value is symbol;

/**
 * Checks whether a given value is `undefined`.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the value is `undefined`.
 */
declare const isUndefined: (value: unknown) => value is undefined;

/**
 * Checks whether the given value is a WeakMap.
 * Note: this might not work when performed in a different window context.
 *
 * @param   value   The value being evaluated.
 *
 * @returns         Whether the given value is a WeakMap or not.
 */
declare const isWeakMap: (value: unknown) => value is WeakMap<any, any>;

type PointTuple = readonly [number, number];
type PointObject = {
    x: number;
    y: number;
};

/**
 * Calculates the clockwise angle between two 2D points in degrees in the range `[0..359]`.
 *
 * @param   point1   An object of form `{ x: number; y: number }` describing the first point.
 * @param   point2   An object of form `{ x: number; y: number }` describing the second point.
 *
 * @returns          A distance between two points.
 */
declare function angle(point1: PointObject, point2: PointObject): number;
/**
 * Calculates the clockwise angle between two 2D points in degrees in the range `[0..359]`.
 *
 * @param   point1   A tuple of form `[x: number; y: number]` describing the first point.
 * @param   point2   A tuple of form `[x: number; y: number]` describing the second point.
 *
 * @returns          A distance between two points.
 */
declare function angle(point1: PointTuple, point2: PointTuple): number;
/**
 * Calculates the clockwise angle between two 2D points in degrees in the range `[0..359]`.
 *
 * @param   x1   `x` coordinate of the first point.
 * @param   y1   `y` coordinate of the first point.
 * @param   x2   `x` coordinate of the second point.
 * @param   y2   `y` coordinate of the second point.
 *
 * @returns      A distance between two points.
 */
declare function angle(x1: number, y1: number, x2: number, y2: number): number;

/**
 * Calculates a distance between two 2D points.
 *
 * @param   point1   An object of form `{ x: number; y: number }` describing the first point.
 * @param   point2   An object of form `{ x: number; y: number }` describing the second point.
 *
 * @returns          A distance between two points.
 */
declare function distance(point1: PointObject, point2: PointObject): number;
/**
 * Calculates a distance between two 2D points.
 *
 * @param   point1   A tuple of form `[x: number; y: number]` describing the first point.
 * @param   point2   A tuple of form `[x: number; y: number]` describing the second point.
 *
 * @returns          A distance between two points.
 */
declare function distance(point1: PointTuple, point2: PointTuple): number;
/**
 * Calculates a distance between two 2D points.
 *
 * @param   x1   `x` coordinate of the first point.
 * @param   y1   `y` coordinate of the first point.
 * @param   x2   `x` coordinate of the second point.
 * @param   y2   `y` coordinate of the second point.
 *
 * @returns      A distance between two points.
 */
declare function distance(x1: number, y1: number, x2: number, y2: number): number;

/**
 * Computes the greatest common divisor (gcd) of two or more integers.
 *
 * @param   integers   The list of integers.
 *
 * @returns            Greatest common divisor of given integers, or `null` in case of invalid input.
 */
declare function gcd(...integers: number[]): number | null;
/**
 * Computes the greatest common divisor (gcd) of two or more integers.
 *
 * @param   integers   The array of integers.
 *
 * @returns            Greatest common divisor of given integers, or `null` in case of invalid input.
 */
declare function gcd(integers: number[]): number | null;

/**
 * Bare-bones linear interpolation function.
 *
 * @param   start    The initial value.
 * @param   end      The final value.
 * @param   amount   Amount of interpolation between `start` and `end` in range `[0..1]`.
 *
 * @returns          The interpolated value.
 */
declare const lerp: (start: number, end: number, amount: number) => number;

/**
 * Clamps a value between an upper and lower bound.
 *
 * @param   value   The preferred value to return.
 * @param   min     The lowest value to return or `null` to skip.
 * @param   max     The highest value to return or `null` to skip.
 *
 * @returns         Value not less than the `min` and not greater than the `max`
 */
declare const clamp: (value: number, min?: number | null, max?: number | null) => number;

type Prefix = 'b' | 'k' | 'm' | 'g' | 't' | 'p' | 'e' | 'z' | 'y';
type Mode = 'metric' | 'IEC';
type Options$5 = {
    /**
     * The needed precision of the return value.
     *
     * @default 1
     */
    precision: number;
    /**
     * The first character of unit for return value or keyword `auto`. \
     * 'k' means 'kB' or 'KiB', 'm' means 'mB' or 'MiB' and so on.
     *
     * @default 'auto'
     */
    to: 'auto' | Prefix;
    /**
     * The base to calculate a value.
     * `metric` uses powers of ten, `IEC` uses powers of two.
     *
     * @default 'metric'
     */
    mode: Mode;
    /**
     * Whether to trim trailing zeros for the value (in a string form)
     */
    trimZeros: boolean;
    /**
     * An overrides for default  units, will be merged with it. \
     * Useful for translations.
     */
    customUnits: {
        [key in Mode]?: Partial<{
            [innerKey in Prefix]: string;
        }>;
    };
    /**
     * Custom formatter for `asString` property of return value, also overrides `.toString` method of object itself.
     *
     * @param   value           Calculated value as number
     * @param   valueAsString   Calculated value as string
     * @param   unit            Calculated unit name
     * @param   isInteger       Whether the calculated value is integer number. Mostly used for `i18n` purposes.
     *
     * @returns                 String representation of return value
     */
    toString: (value: number, valueAsString: string, unit: string, isInteger: boolean) => string;
};
declare class FormatBytes {
    /**
     * The calculated value.
     */
    value: number;
    /**
     * The calculated value in string form with needed precision.
     */
    valueAsString: string;
    /**
     * Calculated unit of value.
     */
    unit: string;
    /**
     * Whether the value is an integer number. \
     * Mostly used for `i18n` purposes.
     */
    isInteger: boolean;
    constructor(bytes: number, customOptions?: Partial<Options$5>);
    toString(): any;
}
declare const formatBytes: (bytes: number, customOptions?: Partial<Options$5>) => FormatBytes;
declare const formatBytesRu: (bytes: number, _customOptions?: Partial<Options$5>) => FormatBytes;

/**
 * Formats a given number with grouped thousands.
 *
 * @param   numberOrStringRepresentingNumber   The number being formatted.
 * @param   decimals                           The number of decimal points. Default 0.
 * @param   fractionSeparator                  The separator for the decimal point. Default `.`.
 * @param   thousandsSeparator                 The thousands separator. Default ` `.
 *
 * @returns                                    Formatted number.
 */
declare const numberFormat: (numberOrStringRepresentingNumber: any, decimals?: number, fractionSeparator?: string, thousandsSeparator?: string) => string;

/**
 * Returns the precision of the number. \
 * If it is impossible to cast given value to a number, returns `null`.
 *
 * @see https://stackoverflow.com/a/73937406
 *
 * @param   maybeNumber   Number (or numeric string) to determine its precision.
 *
 * @returns               A given number precision or `null` in case of invalid input.
 */
declare const precision: (maybeNumber: unknown) => number | null;

/**
 * Generates a random float with given `precision` (including `min` and `max` values).
 *
 * @param   min         The lowest value to return.
 * @param   max         The highest value to return.
 * @param   precision   The needed precision of return value.
 *
 * @returns             The random value between specified min and max values with given precision.
 */
declare const randomFloat: (min: number, max: number, precision?: number) => number;

/**
 * Generates a random integer (including `min` and `max` values). \
 * Returns a random integer between 1 and `MAX_SAFE_INTEGER`
 * if called with no arguments which covers the most frequent use case.
 *
 * @param   min   The lowest value to return.
 * @param   max   The highest value to return.
 *
 * @returns       Random integer value greater than `min` and less than `max` (inclusive)
 */
declare const randomInteger: (min?: number, max?: number) => number;

/**
 * Attempts to cast the passed value to a number.
 * If the cast was successful, returns resulting number.
 * If the cast was unsuccessful, throws an Error unless the fallback value is provided.
 *
 * @param   value      The value to cast.
 * @param   fallback   Fallback value if cast was unsuccessful.
 *
 * @returns            The number if cast was successful, fallback value otherwise if provided.
 *
 * @throws               Throws if cast was unsuccessful with no fallback value provided.
 */
declare function toNumber<F = undefined>(value: unknown, fallback?: F): number | F;

/**
 * Copies a value deeply.
 *
 * @see https://github.com/planttheidea/fast-copy#copy
 *
 * @param   value   The value being processed.
 *
 * @returns         The structured clone of a given value.
 */
declare const deepClone: <T>(value: T) => T;
/**
 * Copies a value deeply considering property descriptors,
 * non-enumerable keys and any non-standard extensions.
 *
 * @see https://github.com/planttheidea/fast-copy#copystrict
 *
 * @param   value   The value being processed.
 *
 * @returns         The structured clone of a given value.
 */
declare const deepCloneStrict: <T>(value: T) => T;

/**
 * Checks if of two objects are the same data (deep equality).
 * There is no support for circular objects.
 *
 * @param   a   The value to compare #1.
 * @param   b   The value to compare #2.
 *
 * @returns     Result of comparing two given values (deep equality).
 */
declare const deepEqual: (a: unknown, b: unknown) => boolean;
/**
 * Checks if of two objects are the same data (deep equality).
 * This version handles circular objects correctly.
 *
 * @param   a   The value to compare #1.
 * @param   b   The value to compare #2.
 *
 * @returns     Result of comparing two given values (deep equality).
 */
declare const deepEqualCircular: (a: unknown, b: unknown) => boolean;

type Input = FormData | PlainObject;
type Entry = FormDataEntryValue | FormDataEntryValue[];
type ToReturn<T extends Input> = T extends FormData ? Record<string, Entry> : T;
/**
 * Converts given `FormData` object (or a plain object) to plain object.
 *
 * @param   formData   The value being evaluated.
 *
 * @returns            Plain object builded from given FormData, or original object if not FormData is passed.
 */
declare const formDataToObject: <T extends Input>(formData: T) => ToReturn<T>;

type MergeObjects<Source extends PlainObject, Input extends PlainObject> = Input extends Source ? Input : (Omit<Source, keyof Source & keyof Input> & Omit<Input, keyof Source & keyof Input> & {
    -readonly [Key in keyof Source & keyof Input]: Input[Key];
});
type MergerFn = <Source extends PlainObject, Input extends PlainObject>(defaults: Source, ...input: Array<Input | null | undefined>) => MergeObjects<Source, Input>;
type Merger = <T extends PlainObject, K extends keyof T>(obj: T, key: keyof T, value: T[K], stack: string) => boolean | undefined;
/**
 * Creates defaults function with custom merger.
 *
 * @param   merger   Custom merger function
 *
 * @returns          Defaults function with custom merger applied.
 */
declare const createMergeObjects: (merger?: Merger) => MergerFn;
/**
 * Mixes properties from source into target when
 *
 * @param   defaults   Source object
 * @param   ...input   Custom object(s) to be merged with source or result of previous merge
 *
 * @returns            Merged object.
 */
declare const mergeObjects: MergerFn;

type PathVariant = string | Array<string | number>;
/**
 * Gets a property from an object using dot (object path) notation.
 *
 * @param   input          The value to search in.
 * @param   path           The path to search using dot or array notation.
 * @param   defaultValue   The value to return if the path doesn't exist.
 *
 * @returns                The value of property in the passed path if exists, `defaultValue` otherwise.
 */
declare const objectGet: (input: unknown, path: PathVariant, defaultValue?: any) => any;

type Case = 'snake_case' | 'PascalCase' | 'kebab-case' | 'camelCase';
type Options$4 = {
    depth: number;
    exclude: Array<string | RegExp>;
    excludeBranches: Array<string | RegExp>;
};
/**
 * Creates a new object from given one with the keys written in needed case.
 *
 * @param   input        Object to convert keys case.
 * @param   neededCase   Needed keys case.
 * @param   _options     Custom options.
 *
 * @returns              New object with keys "renamed" to needed case.
 */
declare const objectKeysCase: (input: unknown, neededCase: Case, _options?: Partial<Options$4>) => unknown;

type Options$3 = {
    /**
     * Whether to include array indices in resulting FormData keys.
     *
     * @default false
     */
    indices: boolean;
    /**
     * What to do with `null` values.
     * * `omit` (default) will skip keys with `null` values (resulting FormData object will no contain these keys);
     * * `preserve-as-string-null` will preserve keys with the value `null` with the string value `null`, copying the default FormData behavior;
     * * `preserve-as-empty-string` will preserve keys with the value `null` with the empty string indicating an empty value.
     *
     * @default 'omit'
     */
    nullValues: 'omit' | 'preserve-as-string-null' | 'preserve-as-empty-string';
    /**
     * What to do with `boolean` values.
     * * `preserve-as-strings` (default) will preserve values as `true` and `false` strings;
     * * `preserve-as-integers` will preserve values as `0` and `1` strings.
     *
     * @default 'preserve-as-strings'
     */
    booleanValues: 'preserve-as-strings' | 'preserve-as-integers';
    /**
     * What to do with empty arrays.
     * * `omit` (default) will skip keys with empty array values (resulting FormData object will no contain these keys);
     * * `preserve` will preserve these keys as empty strings indicating the empty value.
     *
     * @default 'omit'
     */
    emptyArrays: 'omit' | 'preserve';
    /**
     * What to do with square brackets of arrays.
     * * `append` (default) will add square brackets to all keys containing the array as a value;
     * * `append-only-for-files` will add square brackets only to keys containing the files, leaving other array keys without square brackets;
     * * `omit` will remove any square brackets in keys for arrays.
     *
     * @default 'append'
     */
    arrayBrackets: 'append' | 'append-only-for-files' | 'omit';
    /**
     * Which object key notation should be used.
     * * `brackets` (default) will use square brackets, e.g. `foo[bar][baz]`;
     * * `dots` will use dot as a separator, e.g. `foo.bar.baz`.
     *
     * @default 'brackets'
     */
    objectKeysNotation: 'brackets' | 'dots';
};
/**
 * Converts a JS object to FormData object.
 *
 * @param   object             An object to transform into FormData.
 * @param   userOptions        Transformation options.
 * @param   existingFormData   An existing FormData object to extend it instead of creating a new one.
 *
 * @returns                    FormData object constructed from the object given, considering the options.
 */
declare const objectToFormdata: (object: PlainObject, userOptions?: Partial<Options$3> | null, existingFormData?: FormData) => FormData;

/**
 * Removes the specified keys from the given object and returns new object.
 *
 * @param   obj    Original object.
 * @param   keys   Keys of original object to remove.
 *
 * @returns        New object without specified keys
 */
declare const omit: <T, K extends keyof T>(obj: T, ...keys: K[]) => Omit<T, K>;

/**
 * Returns the new object containing only the specified keys.
 *
 * @param   obj    Original object.
 * @param   keys   Keys of original object to pick.
 *
 * @returns        New object containing only the specified keys.
 */
declare const pick: <T extends PlainObject, K extends keyof T>(obj: T, ...keys: K[]) => Pick<T, K>;

/**
 * Object containing typed versions of popular `Object` methods.
 */
declare const tsObject: {
    /**
     * Typed version of `Object.keys()`.
     *
     * @param   obj   Object to process.
     *
     * @returns       `Object.keys()` return value for a given object.
     */
    keys: <T extends PlainObject>(obj: T) => `${Exclude<keyof T, symbol>}`[];
    /**
     * Typed version of `Object.values()`.
     *
     * @param   obj   Object to process.
     *
     * @returns       `Object.values()` return value for a given object.
     */
    values: <T_1 extends PlainObject>(obj: T_1) => ObjectValues<Required<T_1>>;
    /**
     * Typed version of `Object.entries()`.
     *
     * @param   obj   Object to process.
     *
     * @returns       `Object.entries()` return value for a given object.
     */
    entries: <T_2 extends PlainObject>(obj: T_2) => ObjectEntries<Required<T_2>>;
    /**
     * Typed version of `Object.fromEntries()`.
     *
     * @param   entries   Entries to process.
     *
     * @returns           `Object.fromEntries()` return value for a given object.
     */
    fromEntries: <Key extends PropertyKey, Entries extends readonly (readonly [Key, any])[]>(entries: Entries) => ObjectFromEntries<Key, Entries>;
};

/**
 * A wrapper for a promise, guaranteeing that it will not be fulfilled before `minTime` milliseconds.
 * Most often used for better UX, preventing the loader from flickering for 30-100ms, which looks weird.
 *
 * @param   promise   A promise for which you need to provide a minimum amount of time.
 * @param   minTime   Minimum time in which the result will be obtained.
 *
 * @returns           The result of fulfilling a given promise.
 */
declare const minTimePromise: <T>(promise: Promise<T>, minTime?: number) => Promise<any>;

type PromiseController<T = undefined> = Promise<T> & {
    resolve: (value?: T | PromiseLike<T>) => void;
    reject: (reason?: unknown) => void;
};
/**
 * Returns a Promise with `resolve` and `reject` methods itself
 *
 * @returns   Promise with extra `resolve` and `reject` methods
 */
declare const promiseController: <T>() => PromiseController<T>;

type Range = readonly [number | null | undefined, number | null | undefined];
type AvailableRangeValues = ReadonlyArray<Range | null> | null | undefined;
type OutputRange<T, InfToNull extends boolean> = InfToNull extends true ? [number | null, number | null] : T extends Range[] ? null extends IterableElement<IterableElement<T>> ? [number | null, number | null] : [number, number] : [number | null, number | null];

/**
 * Checks whether at least one of provided ranges
 * (or all of them depending on the `mode` argument) includes a given number.
 *
 * @param   value    The number to search in ranges.
 * @param   ranges   The ranges to check for occurrences.
 * @param   mode     Whether the every range includes a number (`all`) or at least one is enough (`any`). Default is `any`.
 *
 * @returns          Is any range (or all of them depending on the `mode` argument) includes a given number.
 */
declare const rangeIncludes: (value: number, ranges: readonly Range[] | null | undefined, mode?: 'all' | 'any') => boolean;

/**
 * Crops an array of ranges if they go beyond the `start` and `end`.
 *
 * @param   ranges           An array of ranges to crop.
 * @param   start            Minimum allowed range value.
 * @param   end              Maximum allowed range value.
 * @param   infinityToNull   Whether the return value should be `null` instead of `+-Infinity`.
 *
 * @returns                  The array of cropped ranges.
 */
declare const rangesCrop: <T extends AvailableRangeValues, I extends boolean = false>(ranges: T, start?: number | null, end?: number | null, infinityToNull?: I) => Array<OutputRange<T, I>>;

type Options$2 = {
    /**
     * Whether to treat identical edges as intersections.
     *
     * @example
     * rangesIntersection([[0, 1], [1, 2]], { inclusive: true });
     * // [[1, 1]]
     *
     * @default false
     */
    inclusive: boolean;
};
/**
 * Calculates the intersections of the passed ranges.
 *
 * @param   ranges        An array of ranges to calculate intersections.
 * @param   userOptions   Custom options.
 *
 * @returns               An array containing all intersections between passed ranges.
 */
declare const rangesIntersection: (ranges: AvailableRangeValues, userOptions?: Partial<Options$2>) => [number, number][];

declare const rangesInvert: <T extends AvailableRangeValues, I extends boolean = false>(ranges: T, start?: number | null, end?: number | null, infinityToNull?: I) => Array<OutputRange<T, I>>;

/**
 * Sorts and merges given ranges.
 *
 * @param   ranges           An array of ranges.
 * @param   joinEdges        Whether to combine ranges if they are contiguous.
 * @param   infinityToNull   Whether to return `null` instead of `Infinity`.
 *
 * @returns                  Sorted and merged ranges or an empty array for invalid input.
 */
declare const rangesMerge: <T extends AvailableRangeValues, I extends boolean = false>(ranges: T, joinEdges?: boolean, infinityToNull?: I) => Array<OutputRange<T, I>>;

/**
 * Sorts given ranges.
 *
 * @param   ranges           An array of ranges.
 * @param   infinityToNull   Whether to convert `Infinity` values to `null`.
 *
 * @returns                  Sorted ranges or an empty array for invalid input.
 */
declare const rangesSort: <T extends AvailableRangeValues, I extends boolean = false>(ranges: T, infinityToNull?: I) => Array<OutputRange<T, I>>;

type CamelCaseOptions = {
    readonly preserveConsecutiveUppercase?: boolean;
};
/**
 * Converts a dash/dot/underscore/space separated string to camelCase: `foo-bar`  `fooBar`
 *
 * @param        input     A string/array of strings to convert to camelCase.
 * @param        options   Additional options being supplied to the `_camelCase`.
 *
 * @returns                The string converted to camelCase.
 *
 * @throws    {TypeError}  Throws if not a string is passed in.
 */
declare const camelCase: (input: string | readonly string[], options?: CamelCaseOptions) => string;

/**
 * Converts the first character of string to upper case.
 *
 * @param   input   The string to capitalize.
 *
 * @returns         Capitalized string.
 */
declare const capitalize: (input: string) => string;

/**
 * Escapes the `RegExp` special characters in a given string.
 *
 * @param   str   The string to escape.
 *
 * @returns       The escaped string.
 */
declare const escapeRegExp: (str: string | null | undefined) => string;

/**
 * Returns the file extension for given filename / filepath.
 *
 * @param   input   Filename / Full path to file
 *
 * @returns         File extension (without leading dot) or `null`
 */
declare const fileExtension: (input: string) => string | null;

type FormatSlashesOptions = {
    /**
     * Slash variant
     */
    to: '/' | '\\';
    /**
     * Should there be a leading slash?
     */
    start: boolean;
    /**
     * Should there be a trailing slash?
     */
    end: boolean;
};
/**
 * Formats given string
 *
 * @param   input     The input string.
 * @param   options   Formatter options.
 *
 * @returns           Formatted string.
 */
declare const formatSlashes: (input: string, options?: Partial<FormatSlashesOptions>) => string;

type Options$1 = {
    /**
     * Whether numbers should be separated.
     */
    numbers: boolean;
};
/**
 * Convert a string to kebab-case: `fooFar`  `foo-bar`
 *
 * @param   input      A string to convert to kebab-case
 * @param   _options   Transform options
 *
 * @returns            The string converted to kebab-case.
 */
declare const kebabCase: (input: string, _options?: Options$1) => string;

/**
 * Pads the given number/string with a given `fillString` (repeated, if needed) so that the resulting string reaches a given length.
 * The padding is applied from the end of the given string.
 *
 * @param   input        String / number to apply pad.
 * @param   maxLength    The length of the resulting string once the given string has been padded.
 * @param   fillString   The string to pad the given string with.
 *
 * @returns              The padded string.
 */
declare const padEnd: (input: string | number, maxLength: number, fillString?: string) => string;

/**
 * Pads the given number/string with a given `fillString` (repeated, if needed) so that the resulting string reaches a given length.
 * The padding is applied from the start of the given string.
 * `maxLength` and `fillString` defaults cover the most popular use case - leading zero to length 2.
 *
 * @param   input        String / number to apply pad.
 * @param   maxLength    The length of the resulting string once the given string has been padded.
 * @param   fillString   The string to pad the given string with.
 *
 * @returns              The padded string.
 */
declare const padStart: (input: string | number, maxLength?: number, fillString?: string) => string;

type PascalCaseOptions = {
    readonly preserveConsecutiveUppercase?: boolean;
};
/**
 * Convert a dash/dot/underscore/space separated string to PascalCase: `foo-bar`  `FooBar`
 *
 * @param   input     A string/array of strings to convert to PascalCase.
 * @param   options   Additional options being supplied to the `_camelCase`.
 *
 * @returns           The string converted to PascalCase.
 */
declare const pascalCase: (input: string | readonly string[], options?: PascalCaseOptions) => string;

/**
 * Quotes the given string with specified `char`.
 *
 * @param   str    String to be quoted.
 * @param   char   Quote character.
 *
 * @returns        Quoted string.
 */
declare const quote: (str: string, char?: string) => string;

/**
 * Generates a random string of a given length and (optionally) starting with a latin character
 * (if used to fill `id` of HTMLElement for example)
 *
 * @param   length           The length of result string. \
 *                           Default is `10`.
 * @param   startWithLatin   Should string strictly start with latin character or not. \
 *                           Default is `true`.
 *
 * @returns                  Generated string of a given length.
 */
declare const randomString: (length?: number, startWithLatin?: boolean) => string;

/**
 * Retrieves Roman representation of given integer number.
 *
 * @param   num   Integer value to transform to Roman notation
 *
 * @returns       Roman representation of given number
 */
declare const romanize: (num: number) => string;

/**
 * Convert a string to snake-case: `fooFar`  `foo_bar`
 *
 * @param   input   A string to convert to snake-case
 *
 * @returns         The string converted to snake-case.
 */
declare const snakeCase: (input: string) => string;

type Options = {
    /**
     * Whether to remove leading linebreaks and spacings (before the first non-space character)
     *
     * @default true
     */
    trimLeadingSpacings: boolean;
    /**
     * Whether to remove trailing linebreaks and spacings (after the last non-space character)
     *
     * @default true
     */
    trimTrailingSpacings: boolean;
};
/**
 * Removes an extra indentation of the string. \
 * Useful to work with template literal strings.
 *
 * @param   input         String to remove an extra indentation.
 * @param   userOptions   Extra options.
 *
 * @returns               The string with minimal required indentation.
 */
declare const stripIndent: (input: string, userOptions?: Partial<Options>) => string;

/**
 * Unquotes the given string.
 *
 * @param   str   String to unquote.
 *
 * @returns       String without start/end quotes/backticks.
 */
declare const unquote: (str: string) => string;

/**
 * Stringify an object for use in a query string.
 *
 * @param   object   An object to stringify.
 * @param   prefix   A prefix for root element.
 *
 * @returns          Query string built from the object.
 */
declare const queryStringify: (object: PlainObject | undefined, prefix?: string) => string;

export { type ArrayOf, type Arrayable, type Builtin, type Cookie, type EndsWith, FORMAT_DATE_LOCALE_EN, FORMAT_DATE_LOCALE_RU, type NonEmptyArray, type Nullable, type ObjectEntries, type ObjectFromEntries, type ObjectKeys, type ObjectValues, type PlainObject, type StartsWith, type Trim, type TrimEnd, type TrimStart, type TupleOf, angle, arrayInsert, arrayInsertMutable, arrayOfLength, arrayRange, arrayRemove, arrayRemoveMutable, arraySample, arrayShuffle, arraySwap, arraySwapMutable, arrayUnique, arraysDifference, arraysIntersection, arraysUnion, assert, asyncArray, camelCase, capitalize, clamp, compose, configureAssert, createFormatDate, createMergeObjects, daysInMonth, debounce, deepClone, deepCloneStrict, deepEqual, deepEqualCircular, distance, escapeRegExp, fileExtension, formDataToObject, formatBytes, formatBytesRu, formatDate, formatDateEn, formatDateRu, formatSlashes, gcd, getDocumentSize, getElement, getElementOffset, getScrollLimit, getScrollableAncestor, getScrollbarWidth, getWindowScroll, hash, isArray, isBlob, isBoolean, isClient, isDate, isDev, isElement, isEmail, isEmpty, isError, isFile, isFirefox, isFloat, isFormData, isFunction, isHex, isInteger, isInternetExplorer, isIsoDate, isIterable, isLeapYear, isLighthouse, isLocalStorageAvailable, isMap, isMobile, isMotionless, isNode, isNull, isNullish, isNumeric, isOSX, isObject, isPlainObject, isPrimitive, isProd, isPromise, isRegExp, isServer, isSessionStorageAvailable, isString, isSymbol, isTest, isTouch, isUndefined, isWeakMap, kebabCase, lerp, mergeObjects, minTimePromise, noop, numberFormat, objectGet, objectKeysCase, objectToFormdata, omit, padEnd, padStart, parseDate, parseResponseCookie, pascalCase, pick, precision, promiseController, queryStringify, quote, randomDate, randomFloat, randomInteger, randomString, rangeIncludes, rangesCrop, rangesIntersection, rangesInvert, rangesMerge, rangesSort, romanize, safeJsonParse, serializeCookie, sleep, snakeCase, stripIndent, supportsPassive, throttle, toArray, toDate, toNumber, tsObject, unquote, verifyFileAccept, withProbability };
