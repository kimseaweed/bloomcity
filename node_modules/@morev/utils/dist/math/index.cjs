"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/math/index.ts
var math_exports = {};
__export(math_exports, {
  angle: () => angle,
  distance: () => distance,
  gcd: () => gcd,
  lerp: () => lerp
});
module.exports = __toCommonJS(math_exports);

// src/guards/is-array/is-array.ts
var isArray = (value) => Array.isArray(value);

// src/guards/is-object/is-object.ts
var isObject = (value) => Object.prototype.toString.call(value).includes("Object");

// src/guards/is-numeric/is-numeric.ts
var isNumeric = (value) => typeof value === "number" && !isNaN(value);

// src/guards/is-integer/is-integer.ts
var isInteger = (value) => Number.isInteger(value);

// src/guards/is-null/is-null.ts
var isNull = (value) => value === null;

// src/math/angle/angle.ts
function angle(arg1, arg2, arg3, arg4) {
  const [p1, p2] = (() => {
    if (isObject(arg1) && isObject(arg2)) {
      return [[arg1.x, arg1.y], [arg2.x, arg2.y]];
    }
    if (isArray(arg1) && isArray(arg2)) {
      return [arg1, arg2];
    }
    if (isNumeric(arg1) && isNumeric(arg2) && isNumeric(arg3) && isNumeric(arg4)) {
      return [[arg1, arg2], [arg3, arg4]];
    }
    return [null, null];
  })();
  if (isNull(p1) || isNull(p2))
    return null;
  const [[x1, y1], [x2, y2]] = [p1, p2];
  const [dx, dy] = [x2 - x1, y2 - y1];
  const theta = Math.atan2(dx, dy) * 180 / Math.PI;
  return theta < 0 ? theta + 360 : theta;
}

// src/math/distance/distance.ts
function distance(arg1, arg2, arg3, arg4) {
  const [p1, p2] = (() => {
    if (isObject(arg1) && isObject(arg2)) {
      return [[arg1.x, arg1.y], [arg2.x, arg2.y]];
    }
    if (isArray(arg1) && isArray(arg2)) {
      return [arg1, arg2];
    }
    if (isNumeric(arg1) && isNumeric(arg2) && isNumeric(arg3) && isNumeric(arg4)) {
      return [[arg1, arg2], [arg3, arg4]];
    }
    return [null, null];
  })();
  if (isNull(p1) || isNull(p2))
    return null;
  const [[x1, y1], [x2, y2]] = [p1, p2];
  return Math.hypot(x1 - x2, y1 - y2);
}

// src/math/gcd/gcd.ts
var _gcdBinary = (a, b) => {
  let factor = 1;
  while (a % 2 === 0 && b % 2 === 0) {
    [a, b, factor] = [a / 2, b / 2, factor * 2];
  }
  while (a % 2 === 0)
    a = a / 2;
  while (b) {
    while (b % 2 === 0)
      b = b / 2;
    if (a > b)
      [a, b] = [b, a];
    b = b - a;
  }
  return factor * a;
};
var _gcdBitwise = (a, b) => {
  let factor = 0;
  while ((a & 1) === 0 && (b & 1) === 0) {
    a >>>= 1;
    b >>>= 1;
    factor++;
  }
  while ((a & 1) === 0)
    a >>>= 1;
  while (b) {
    while ((b & 1) === 0)
      b >>>= 1;
    if (a > b)
      [a, b] = [b, a];
    b = b - a;
  }
  return a << factor;
};
var _gcd = (a, b) => {
  if (a === 0)
    return b;
  if (b === 0)
    return a;
  [a, b] = [Math.abs(a), Math.abs(b)];
  const mode = a < Number.MAX_SAFE_INTEGER && b < Number.MAX_SAFE_INTEGER ? "bitwise" : "binary";
  return mode === "binary" ? _gcdBinary(a, b) : _gcdBitwise(a, b);
};
function gcd(...args) {
  const numbers = isArray(args[0]) ? args[0] : args;
  const { length } = numbers;
  if (length < 2)
    return null;
  if (numbers.some((number) => !isInteger(number)))
    return null;
  return numbers.reduce((acc, b) => _gcd(acc, b));
}

// src/math/lerp/lerp.ts
var lerp = (start, end, amount) => {
  return (1 - amount) * start + amount * end;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  angle,
  distance,
  gcd,
  lerp
});
