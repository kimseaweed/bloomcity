"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/math/gcd/gcd.ts
var gcd_exports = {};
__export(gcd_exports, {
  gcd: () => gcd
});
module.exports = __toCommonJS(gcd_exports);

// src/guards/is-array/is-array.ts
var isArray = (value) => Array.isArray(value);

// src/guards/is-integer/is-integer.ts
var isInteger = (value) => Number.isInteger(value);

// src/math/gcd/gcd.ts
var _gcdBinary = (a, b) => {
  let factor = 1;
  while (a % 2 === 0 && b % 2 === 0) {
    [a, b, factor] = [a / 2, b / 2, factor * 2];
  }
  while (a % 2 === 0)
    a = a / 2;
  while (b) {
    while (b % 2 === 0)
      b = b / 2;
    if (a > b)
      [a, b] = [b, a];
    b = b - a;
  }
  return factor * a;
};
var _gcdBitwise = (a, b) => {
  let factor = 0;
  while ((a & 1) === 0 && (b & 1) === 0) {
    a >>>= 1;
    b >>>= 1;
    factor++;
  }
  while ((a & 1) === 0)
    a >>>= 1;
  while (b) {
    while ((b & 1) === 0)
      b >>>= 1;
    if (a > b)
      [a, b] = [b, a];
    b = b - a;
  }
  return a << factor;
};
var _gcd = (a, b) => {
  if (a === 0)
    return b;
  if (b === 0)
    return a;
  [a, b] = [Math.abs(a), Math.abs(b)];
  const mode = a < Number.MAX_SAFE_INTEGER && b < Number.MAX_SAFE_INTEGER ? "bitwise" : "binary";
  return mode === "binary" ? _gcdBinary(a, b) : _gcdBitwise(a, b);
};
function gcd(...args) {
  const numbers = isArray(args[0]) ? args[0] : args;
  const { length } = numbers;
  if (length < 2)
    return null;
  if (numbers.some((number) => !isInteger(number)))
    return null;
  return numbers.reduce((acc, b) => _gcd(acc, b));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  gcd
});
