"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/cookies/parse-response-cookie/parse-response-cookie.ts
var parse_response_cookie_exports = {};
__export(parse_response_cookie_exports, {
  parseResponseCookie: () => parseResponseCookie
});
module.exports = __toCommonJS(parse_response_cookie_exports);

// src/guards/is-array/is-array.ts
var isArray = (value) => Array.isArray(value);

// src/guards/is-date/is-date.ts
var isDate = (value, checkValidity) => {
  const isDateObject = Object.prototype.toString.call(value).includes("Date");
  if (!isDateObject)
    return false;
  if (!checkValidity)
    return isDateObject;
  return !Number.isNaN(value.getTime());
};

// src/guards/is-string/is-string.ts
var isString = (value) => Object.prototype.toString.call(value) === "[object String]";

// src/guards/is-iterable/is-iterable.ts
var isIterable = (value) => (
  // eslint-disable-next-line unicorn/new-for-builtins
  Symbol.iterator in Object(value)
);

// src/guards/is-object/is-object.ts
var isObject = (value) => Object.prototype.toString.call(value).includes("Object");

// src/guards/is-empty/is-empty.ts
var isEmpty = (value) => {
  if (value === void 0)
    return true;
  if (value === null)
    return true;
  if (value === false)
    return true;
  if (Number.isNaN(value))
    return true;
  if (value === 0)
    return true;
  if (value === BigInt(0))
    return true;
  if (value === "")
    return true;
  if (isIterable(value) && typeof value === "object" && "length" in value && value.length === 0)
    return true;
  if (isIterable(value) && typeof value === "object" && "size" in value && value.size === 0)
    return true;
  if (isObject(value))
    return !Object.keys(value).length;
  return false;
};

// src/guards/is-function/is-function.ts
var isFunction = (value) => Object.prototype.toString.call(value) === "[object Function]";

// src/arrays/to-array/to-array.ts
var toArray = (value) => [value].flat();

// src/strings/capitalize/capitalize.ts
var capitalize = (input) => {
  if (!input.length)
    return "";
  return input[0].toUpperCase() + input.slice(1);
};

// src/cookies/parse-response-cookie/parse-response-cookie.utils.ts
var parseNameValuePair = (maybePair) => {
  const parts = maybePair.split("=");
  if (parts.length === 1) {
    return { name: "", value: maybePair };
  }
  if (parts.length > 1) {
    const [name, ...values] = parts;
    return { name, value: values.join("=") };
  }
  return null;
};
var DEFAULT_OPTIONS = {
  decodeValues: true,
  returnType: "array"
};
var parseCookieChunk = (chunk, decodeValues) => {
  const parts = chunk.split(";").filter(Boolean);
  const pair = parts.shift();
  if (!pair)
    return null;
  const parsed = parseNameValuePair(pair);
  if (!parsed)
    return null;
  const value = (() => {
    if (!decodeValues)
      return parsed.value;
    try {
      return decodeURIComponent(parsed.value);
    } catch {
      return parsed.value;
    }
  })();
  const cookie = {
    name: parsed.name,
    value
  };
  parts.forEach((part) => {
    const sides = part.split("=");
    if (isEmpty(sides))
      return;
    const key = sides.shift().trim().toLowerCase();
    const keyValue = sides.join("=");
    if (key === "expires") {
      const maybeDate = new Date(keyValue);
      if (!isDate(maybeDate, true))
        return;
      cookie.expires = new Date(keyValue);
      return;
    }
    if (key === "max-age") {
      const maybeNumber = parseInt(keyValue, 10);
      if (Number.isNaN(maybeNumber))
        return;
      cookie.maxAge = maybeNumber;
      return;
    }
    if (key === "secure") {
      cookie.secure = true;
      return;
    }
    if (key === "httponly") {
      cookie.httpOnly = true;
      return;
    }
    if (key === "samesite") {
      if (keyValue.toLowerCase() === "strict" || keyValue.toLowerCase() === "lax" || keyValue.toLowerCase() === "none") {
        cookie.sameSite = capitalize(keyValue.toLowerCase());
      }
      return;
    }
    if (key === "partitioned") {
      cookie.partitioned = true;
      return;
    }
    if (key === "priority") {
      if (keyValue.toLowerCase() === "low" || keyValue.toLowerCase() === "medium" || keyValue.toLowerCase() === "high") {
        cookie.priority = capitalize(keyValue.toLowerCase());
      }
      return;
    }
    keyValue && (cookie[key] = keyValue);
  });
  return cookie;
};
var splitCookiesString = (cookiesString) => {
  if (isArray(cookiesString))
    return cookiesString;
  if (!isString(cookiesString))
    return [];
  const cookieStrings = [];
  let position = 0;
  const skipWhitespace = () => {
    while (position < cookiesString.length && /\s/.test(cookiesString[position])) {
      position++;
    }
    return position < cookiesString.length;
  };
  const notSpecialCharacter = () => {
    return !["=", ";", ","].includes(cookiesString[position]);
  };
  while (position < cookiesString.length) {
    let start = position;
    let cookiesSeparatorFound = false;
    let lastComma = 0;
    let nextStart = 0;
    while (skipWhitespace()) {
      if (cookiesString[position] !== ",") {
        position++;
        continue;
      }
      lastComma = position++;
      skipWhitespace();
      nextStart = position;
      while (notSpecialCharacter() && position < cookiesString.length) {
        position++;
      }
      if (position < cookiesString.length && cookiesString[position] === "=") {
        cookiesSeparatorFound = true;
        position = nextStart;
        cookieStrings.push(cookiesString.slice(start, lastComma));
        start = position;
      } else {
        position = lastComma + 1;
      }
    }
    if (!cookiesSeparatorFound || position >= cookiesString.length) {
      cookieStrings.push(cookiesString.slice(start, cookiesString.length));
    }
  }
  return cookieStrings;
};

// src/cookies/parse-response-cookie/parse-response-cookie.ts
var parseResponseCookie = (input, userOptions) => {
  const options = { ...DEFAULT_OPTIONS, ...userOptions };
  if (isEmpty(input)) {
    return options.returnType === "array" ? [] : {};
  }
  const setCookieValue = toArray((() => {
    if (isString(input))
      return splitCookiesString(input);
    if (isArray(input))
      return input.reduce((acc, value) => [...acc, ...splitCookiesString(value)], []);
    if (isObject(input) && "headers" in input) {
      if (isFunction(input.headers.getSetCookie))
        return splitCookiesString(input.headers.getSetCookie());
      if ("set-headers" in input.headers) {
        return splitCookiesString(input.headers["set-cookie"]) ?? "";
      }
      const key = Object.keys(input.headers).find((header) => header.toLowerCase() === "set-cookie");
      if (key && key in input.headers) {
        return splitCookiesString(input.headers[key]);
      }
      return "";
    }
    return "";
  })()).filter(Boolean);
  return options.returnType === "array" ? setCookieValue.map((chunk) => {
    return parseCookieChunk(chunk, options.decodeValues);
  }).filter(Boolean) : setCookieValue.reduce((acc, chunk) => {
    const cookie = parseCookieChunk(chunk, options.decodeValues);
    if (!cookie)
      return acc;
    acc[cookie.name] = cookie;
    return acc;
  }, {});
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  parseResponseCookie
});
