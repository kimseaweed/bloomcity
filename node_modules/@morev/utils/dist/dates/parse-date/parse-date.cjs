"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/dates/parse-date/parse-date.ts
var parse_date_exports = {};
__export(parse_date_exports, {
  parseDate: () => parseDate
});
module.exports = __toCommonJS(parse_date_exports);

// src/guards/is-date/is-date.ts
var isDate = (value, checkValidity) => {
  const isDateObject = Object.prototype.toString.call(value).includes("Date");
  if (!isDateObject)
    return false;
  if (!checkValidity)
    return isDateObject;
  return !Number.isNaN(value.getTime());
};

// src/guards/is-integer/is-integer.ts
var isInteger = (value) => Number.isInteger(value);

// src/guards/is-undefined/is-undefined.ts
var isUndefined = (value) => value === void 0;

// src/dates/dates.utils.ts
var ISO_DATETIME_REG_EXP = /^(\d{4})-(0[1-9]|1[02])-(0[1-9]|[12]\d|3[01])(?:[ T](0\d|1\d|2[0-3]):([0-5]\d):([0-5]\d)(?:\.(\d{3}))?(?:Z|([+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?))?)?$/;
var RU_DATETIME_REG_EXP = /^([1-9]|0\d|[12]\d|3[01])\.(0[1-9]|[1-9]|1[0-2])\.(\d{4})(?:\s*([01]\d|2[0-3]|\d)(?::(0\d|[1-5]\d|\d))?(?::(0\d|[1-5]\d|\d))?(?:.(\d{3}))?)?$/;
var EN_DATETIME_REG_EXP = /^(0[1-9]|[1-9]|1[0-2])\/([1-9]|0\d|[12]\d|3[01])\/(\d{4})(?:\s*([01]\d|2[0-3]|\d)(?::(0\d|[1-5]\d|\d))?(?::(0\d|[1-5]\d|\d))?(?:.(\d{3}))?)?$/;
var prefixedDateMethodsFactory = (type, utc) => {
  return (string) => {
    const prefix = /* @__PURE__ */ (() => {
      const value = type === "get" ? utc ? "getUTC" : "get" : utc ? "setUTC" : "set";
      return value;
    })();
    return `${prefix}${string}`;
  };
};
var createDateFromTokens = (tokens) => {
  const date = new Date(Date.UTC(tokens.year, tokens.month, tokens.day));
  if (date.getUTCMonth() !== tokens.month || date.getUTCDate() !== tokens.day) {
    return null;
  }
  date.setUTCHours(tokens.hours);
  date.setUTCMinutes(tokens.minutes);
  date.setUTCSeconds(tokens.seconds);
  date.setUTCMilliseconds(tokens.milliseconds);
  if (!tokens.offset)
    return date;
  date.setUTCMinutes(date.getUTCMinutes() + tokens.offset);
  return date;
};

// src/dates/parse-date/parse-date.ts
var tokensFromDate = (date, utc) => {
  if (!date)
    return null;
  const get = prefixedDateMethodsFactory("get", utc);
  date.setUTCMinutes(date.getUTCMinutes() + (/* @__PURE__ */ new Date()).getTimezoneOffset());
  const year = date[get("FullYear")]();
  const month = date[get("Month")]();
  const day = date[get("Date")]();
  const hours = date[get("Hours")]();
  const minutes = date[get("Minutes")]();
  const seconds = date[get("Seconds")]();
  const milliseconds = date[get("Milliseconds")]();
  return { year, month, day, hours, minutes, seconds, milliseconds };
};
var DEFAULT_OPTIONS = { utc: false };
var parseDate = (input, userOptions) => {
  const options = { ...DEFAULT_OPTIONS, ...userOptions };
  if (isDate(input)) {
    if (!isDate(input, true))
      return null;
    const year = input.getFullYear();
    const month = input.getMonth();
    const day = input.getDate();
    const hours = input.getHours();
    const minutes = input.getMinutes();
    const seconds = input.getSeconds();
    const milliseconds = input.getMilliseconds();
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds }),
      options.utc
    );
  }
  if (isInteger(input)) {
    return tokensFromDate(new Date(input), options.utc);
  }
  let match = input.match(ISO_DATETIME_REG_EXP);
  if (match) {
    const [
      year,
      month,
      day,
      hours,
      minutes,
      seconds,
      milliseconds,
      offset
    ] = match.slice(1).map((part, index) => {
      if (isUndefined(part))
        return 0;
      if (index === 1)
        return Number(part) - 1;
      if (index === 7) {
        const [sign, offsetString] = [part[0], part.slice(1)];
        const offset2 = (() => {
          if (offsetString.length === 2) {
            return Number(offsetString) * 60;
          }
          if (offsetString.length === 4) {
            return Number(offsetString.slice(0, 2)) * 60 + Number(offsetString.slice(2));
          }
          return Number(offsetString.slice(0, 2)) * 60 + Number(offsetString.slice(3));
        })();
        return sign === "+" ? offset2 : -offset2;
      }
      return Number(part);
    });
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds, offset }),
      options.utc
    );
  }
  match = input.match(RU_DATETIME_REG_EXP);
  if (match) {
    const [
      day,
      month,
      year,
      hours,
      minutes,
      seconds,
      milliseconds
    ] = match.slice(1).map((part, index) => {
      if (isUndefined(part))
        return 0;
      if (index === 1)
        return Number(part) - 1;
      return Number(part);
    });
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds }),
      options.utc
    );
  }
  match = input.match(EN_DATETIME_REG_EXP);
  if (match) {
    const [
      month,
      day,
      year,
      hours,
      minutes,
      seconds,
      milliseconds
    ] = match.slice(1).map((part, index) => {
      if (isUndefined(part))
        return 0;
      if (index === 0)
        return Number(part) - 1;
      return Number(part);
    });
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds }),
      options.utc
    );
  }
  return null;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  parseDate
});
