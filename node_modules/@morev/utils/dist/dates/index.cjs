"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/dates/index.ts
var dates_exports = {};
__export(dates_exports, {
  FORMAT_DATE_LOCALE_EN: () => FORMAT_DATE_LOCALE_EN,
  FORMAT_DATE_LOCALE_RU: () => FORMAT_DATE_LOCALE_RU,
  createFormatDate: () => createFormatDate,
  daysInMonth: () => daysInMonth,
  formatDate: () => formatDate,
  formatDateEn: () => formatDateEn,
  formatDateRu: () => formatDateRu,
  isIsoDate: () => isIsoDate,
  isLeapYear: () => isLeapYear,
  parseDate: () => parseDate,
  randomDate: () => randomDate,
  toDate: () => toDate
});
module.exports = __toCommonJS(dates_exports);

// src/dates/days-in-month/days-in-month.ts
var daysInMonth = (monthIndex, year) => {
  year ??= (/* @__PURE__ */ new Date()).getFullYear();
  return new Date(year, monthIndex + 1, 0).getDate();
};

// src/guards/is-array/is-array.ts
var isArray = (value) => Array.isArray(value);

// src/guards/is-date/is-date.ts
var isDate = (value, checkValidity) => {
  const isDateObject = Object.prototype.toString.call(value).includes("Date");
  if (!isDateObject)
    return false;
  if (!checkValidity)
    return isDateObject;
  return !Number.isNaN(value.getTime());
};

// src/guards/is-string/is-string.ts
var isString = (value) => Object.prototype.toString.call(value) === "[object String]";

// src/guards/is-object/is-object.ts
var isObject = (value) => Object.prototype.toString.call(value).includes("Object");

// src/guards/is-integer/is-integer.ts
var isInteger = (value) => Number.isInteger(value);

// src/guards/is-null/is-null.ts
var isNull = (value) => value === null;

// src/guards/is-undefined/is-undefined.ts
var isUndefined = (value) => value === void 0;

// src/numbers/clamp/clamp.ts
var clamp = (value, min = -Infinity, max = Infinity) => Math.max(
  min ?? -Infinity,
  Math.min(value, max ?? Infinity)
);

// src/arrays/to-array/to-array.ts
var toArray = (value) => [value].flat();

// src/objects/merge-objects/merge-objects.ts
var _mergeObjects = (defaults, input, stack = "", merger) => {
  const result = { ...defaults };
  if (!isObject(input))
    return result;
  Object.entries(input).forEach(([key, val]) => {
    if (merger?.(result, key, val, stack))
      return;
    if (isObject(val) && isObject(result[key])) {
      Object.assign(result, { [key]: _mergeObjects(result[key], val, (stack ? `${stack}.` : "") + key, merger) });
    } else {
      Object.assign(result, { [key]: val });
    }
  });
  return result;
};
var createMergeObjects = (merger) => (...args) => args.reduce((p, c) => _mergeObjects(p, c, "", merger), {});
var mergeObjects = createMergeObjects();

// src/strings/pad-start/pad-start.ts
var padStart = (input, maxLength = 2, fillString = "0") => input.toString().padStart(maxLength, fillString);

// src/dates/dates.utils.ts
var ISO_DATETIME_REG_EXP = /^(\d{4})-(0[1-9]|1[02])-(0[1-9]|[12]\d|3[01])(?:[ T](0\d|1\d|2[0-3]):([0-5]\d):([0-5]\d)(?:\.(\d{3}))?(?:Z|([+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?))?)?$/;
var RU_DATETIME_REG_EXP = /^([1-9]|0\d|[12]\d|3[01])\.(0[1-9]|[1-9]|1[0-2])\.(\d{4})(?:\s*([01]\d|2[0-3]|\d)(?::(0\d|[1-5]\d|\d))?(?::(0\d|[1-5]\d|\d))?(?:.(\d{3}))?)?$/;
var EN_DATETIME_REG_EXP = /^(0[1-9]|[1-9]|1[0-2])\/([1-9]|0\d|[12]\d|3[01])\/(\d{4})(?:\s*([01]\d|2[0-3]|\d)(?::(0\d|[1-5]\d|\d))?(?::(0\d|[1-5]\d|\d))?(?:.(\d{3}))?)?$/;
var prefixedDateMethodsFactory = (type, utc) => {
  return (string) => {
    const prefix = /* @__PURE__ */ (() => {
      const value = type === "get" ? utc ? "getUTC" : "get" : utc ? "setUTC" : "set";
      return value;
    })();
    return `${prefix}${string}`;
  };
};
var createDateFromTokens = (tokens) => {
  const date = new Date(Date.UTC(tokens.year, tokens.month, tokens.day));
  if (date.getUTCMonth() !== tokens.month || date.getUTCDate() !== tokens.day) {
    return null;
  }
  date.setUTCHours(tokens.hours);
  date.setUTCMinutes(tokens.minutes);
  date.setUTCSeconds(tokens.seconds);
  date.setUTCMilliseconds(tokens.milliseconds);
  if (!tokens.offset)
    return date;
  date.setUTCMinutes(date.getUTCMinutes() + tokens.offset);
  return date;
};

// src/dates/parse-date/parse-date.ts
var tokensFromDate = (date, utc) => {
  if (!date)
    return null;
  const get = prefixedDateMethodsFactory("get", utc);
  date.setUTCMinutes(date.getUTCMinutes() + (/* @__PURE__ */ new Date()).getTimezoneOffset());
  const year = date[get("FullYear")]();
  const month = date[get("Month")]();
  const day = date[get("Date")]();
  const hours = date[get("Hours")]();
  const minutes = date[get("Minutes")]();
  const seconds = date[get("Seconds")]();
  const milliseconds = date[get("Milliseconds")]();
  return { year, month, day, hours, minutes, seconds, milliseconds };
};
var DEFAULT_OPTIONS = { utc: false };
var parseDate = (input, userOptions) => {
  const options = { ...DEFAULT_OPTIONS, ...userOptions };
  if (isDate(input)) {
    if (!isDate(input, true))
      return null;
    const year = input.getFullYear();
    const month = input.getMonth();
    const day = input.getDate();
    const hours = input.getHours();
    const minutes = input.getMinutes();
    const seconds = input.getSeconds();
    const milliseconds = input.getMilliseconds();
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds }),
      options.utc
    );
  }
  if (isInteger(input)) {
    return tokensFromDate(new Date(input), options.utc);
  }
  let match = input.match(ISO_DATETIME_REG_EXP);
  if (match) {
    const [
      year,
      month,
      day,
      hours,
      minutes,
      seconds,
      milliseconds,
      offset
    ] = match.slice(1).map((part, index) => {
      if (isUndefined(part))
        return 0;
      if (index === 1)
        return Number(part) - 1;
      if (index === 7) {
        const [sign, offsetString] = [part[0], part.slice(1)];
        const offset2 = (() => {
          if (offsetString.length === 2) {
            return Number(offsetString) * 60;
          }
          if (offsetString.length === 4) {
            return Number(offsetString.slice(0, 2)) * 60 + Number(offsetString.slice(2));
          }
          return Number(offsetString.slice(0, 2)) * 60 + Number(offsetString.slice(3));
        })();
        return sign === "+" ? offset2 : -offset2;
      }
      return Number(part);
    });
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds, offset }),
      options.utc
    );
  }
  match = input.match(RU_DATETIME_REG_EXP);
  if (match) {
    const [
      day,
      month,
      year,
      hours,
      minutes,
      seconds,
      milliseconds
    ] = match.slice(1).map((part, index) => {
      if (isUndefined(part))
        return 0;
      if (index === 1)
        return Number(part) - 1;
      return Number(part);
    });
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds }),
      options.utc
    );
  }
  match = input.match(EN_DATETIME_REG_EXP);
  if (match) {
    const [
      month,
      day,
      year,
      hours,
      minutes,
      seconds,
      milliseconds
    ] = match.slice(1).map((part, index) => {
      if (isUndefined(part))
        return 0;
      if (index === 0)
        return Number(part) - 1;
      return Number(part);
    });
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds }),
      options.utc
    );
  }
  return null;
};

// src/dates/to-date/to-date.ts
var DEFAULT_OPTIONS2 = { utc: false };
var toDate = (value, userOptions) => {
  const options = { ...DEFAULT_OPTIONS2, ...userOptions };
  const tokens = parseDate(value, { utc: options.utc });
  if (!tokens)
    return null;
  const offset = (/* @__PURE__ */ new Date()).getTimezoneOffset();
  return createDateFromTokens({
    ...tokens,
    offset: options.utc ? -offset : offset
  });
};

// src/dates/format-date/format-date.locales.ts
var FORMAT_DATE_LOCALE_EN = {
  name: "en",
  values: {
    firstDayOfWeekIndex: 0,
    dayNames: {
      abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    },
    monthNames: {
      abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    }
  }
};
var FORMAT_DATE_LOCALE_RU = {
  name: "ru",
  values: {
    firstDayOfWeekIndex: 1,
    dayNames: {
      abbreviated: ["\u0412\u0441", "\u041F\u043D", "\u0412\u0442", "\u0421\u0440", "\u0427\u0442", "\u041F\u0442", "\u0421\u0431"],
      wide: [
        ["\u0412\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435", "\u0412 \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435"],
        ["\u041F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A", "\u0412 \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A"],
        ["\u0412\u0442\u043E\u0440\u043D\u0438\u043A", "\u0412\u043E \u0432\u0442\u043E\u0440\u043D\u0438\u043A"],
        ["\u0421\u0440\u0435\u0434\u0430", "\u0412 \u0441\u0440\u0435\u0434\u0443"],
        ["\u0427\u0435\u0442\u0432\u0435\u0440\u0433", "\u0412 \u0447\u0435\u0442\u0432\u0435\u0440\u0433"],
        ["\u041F\u044F\u0442\u043D\u0438\u0446\u0430", "\u0412 \u043F\u044F\u0442\u043D\u0438\u0446\u0443"],
        ["\u0421\u0443\u0431\u0431\u043E\u0442\u0430", "\u0412 \u0441\u0443\u0431\u0431\u043E\u0442\u0443"]
      ]
    },
    monthNames: {
      abbreviated: ["\u042F\u043D\u0432", "\u0424\u0435\u0432", "\u041C\u0430\u0440\u0442", "\u0410\u043F\u0440", "\u041C\u0430\u0439", "\u0418\u044E\u043D\u044C", "\u0418\u044E\u043B\u044C", "\u0410\u0432\u0433", "\u0421\u0435\u043D", "\u041E\u043A\u0442", "\u041D\u043E\u044F", "\u0414\u0435\u043A"],
      wide: [
        ["\u042F\u043D\u0432\u0430\u0440\u044C", "\u042F\u043D\u0432\u0430\u0440\u044F"],
        ["\u0424\u0435\u0432\u0440\u0430\u043B\u044C", "\u0424\u0435\u0432\u0440\u0430\u043B\u044F"],
        ["\u041C\u0430\u0440\u0442", "\u041C\u0430\u0440\u0442\u0430"],
        ["\u0410\u043F\u0440\u0435\u043B\u044C", "\u0410\u043F\u0440\u0435\u043B\u044F"],
        ["\u041C\u0430\u0439", "\u041C\u0430\u044F"],
        ["\u0418\u044E\u043D\u044C", "\u0418\u044E\u043D\u044F"],
        ["\u0418\u044E\u043B\u044C", "\u0418\u044E\u043B\u044F"],
        ["\u0410\u0432\u0433\u0443\u0441\u0442", "\u0410\u0432\u0433\u0443\u0441\u0442\u0430"],
        ["\u0421\u0435\u043D\u0442\u044F\u0431\u0440\u044C", "\u0421\u0435\u043D\u0442\u044F\u0431\u0440\u044F"],
        ["\u041E\u043A\u0442\u044F\u0431\u0440\u044C", "\u041E\u043A\u0442\u044F\u0431\u0440\u044F"],
        ["\u041D\u043E\u044F\u0431\u0440\u044C", "\u041D\u043E\u044F\u0431\u0440\u044F"],
        ["\u0414\u0435\u043A\u0430\u0431\u0440\u044C", "\u0414\u0435\u043A\u0430\u0431\u0440\u044F"]
      ]
    }
  }
};

// src/dates/format-date/format-date.utils.ts
var TOKEN = /H{1,2}|L{1,4}|M{1,4}|X{1,3}|_L{3,4}|_M{3,4}|_c{3,4}|_e{3,4}|c{1,4}|d{1,2}|e{1,4}|h{1,2}|m{1,2}|s{1,2}|yy(?:yy)?|\[[^\]]*]/g;
var ORDERED_DAY_INDICES = [0, 1, 2, 3, 4, 5, 6];
var pad = (value, length = 2) => padStart(value, length, "0");

// src/dates/format-date/format-date.ts
var _formatDate = (pattern, locales, input, options) => {
  const { utc, locale } = options;
  const date = toDate(input);
  if (!date)
    return null;
  const $i18n = locales.find(({ name }) => name === locale)?.values;
  if (!$i18n) {
    throw new Error(`The locale object for locale \`${locale}\` does not exists.`);
  }
  const localized = (entity, type, variant, index) => {
    const _type = toArray($i18n[`${entity}Names`][type][index]);
    return variant === "standalone" ? _type[0] : _type[1] ?? _type[0];
  };
  const get = prefixedDateMethodsFactory("get", utc);
  const day = () => date[get("Date")]();
  const weekday = () => date[get("Day")]();
  const month = () => date[get("Month")]();
  const year = () => date[get("FullYear")]();
  const hours = () => date[get("Hours")]();
  const minutes = () => date[get("Minutes")]();
  const seconds = () => date[get("Seconds")]();
  const weekdayIndex = () => {
    const offset = weekday() - $i18n.firstDayOfWeekIndex;
    return ORDERED_DAY_INDICES.at(offset) + 1;
  };
  const timezone = (format) => {
    const offset = utc ? 0 : date.getTimezoneOffset();
    if (offset === 0)
      return "Z";
    const sign = offset < 0 ? "+" : "-";
    const offsetHours = Math.floor(Math.abs(offset) / 60);
    const offsetMinutes = Math.abs(offset) - offsetHours * 60;
    const joinCharacter = ["basic", "minimal"].includes(format) ? "" : ":";
    const filterer = format === "minimal" ? (value) => value !== 0 : (value) => true;
    const time = [offsetHours, offsetMinutes].filter((value) => filterer(value)).map((part) => pad(part)).join(joinCharacter);
    return `${sign}${time}`;
  };
  const matchers = {
    // Year
    yy: () => year().toString().slice(-2),
    yyyy: () => pad(year(), 4),
    // Month (standalone)
    L: () => month() + 1,
    LL: () => pad(month() + 1),
    LLL: () => localized("month", "abbreviated", "standalone", month()),
    _LLL: () => localized("month", "abbreviated", "standalone", month()).toLocaleLowerCase(),
    LLLL: () => localized("month", "wide", "standalone", month()),
    _LLLL: () => localized("month", "wide", "standalone", month()).toLocaleLowerCase(),
    // Month (format)
    M: () => month() + 1,
    MM: () => pad(month() + 1),
    MMM: () => localized("month", "abbreviated", "format", month()),
    _MMM: () => localized("month", "abbreviated", "format", month()).toLocaleLowerCase(),
    MMMM: () => localized("month", "wide", "format", month()),
    _MMMM: () => localized("month", "wide", "format", month()).toLocaleLowerCase(),
    // Weekday (standalone)
    c: () => weekdayIndex(),
    cc: () => pad(weekdayIndex()),
    ccc: () => localized("day", "abbreviated", "standalone", weekday()),
    _ccc: () => localized("day", "abbreviated", "standalone", weekday()).toLocaleLowerCase(),
    cccc: () => localized("day", "wide", "standalone", weekday()),
    _cccc: () => localized("day", "wide", "standalone", weekday()).toLocaleLowerCase(),
    // Weekday (format)
    e: () => weekdayIndex(),
    ee: () => pad(weekdayIndex()),
    eee: () => localized("day", "abbreviated", "format", weekday()),
    _eee: () => localized("day", "abbreviated", "format", weekday()).toLocaleLowerCase(),
    eeee: () => localized("day", "wide", "format", weekday()),
    _eeee: () => localized("day", "wide", "format", weekday()).toLocaleLowerCase(),
    // Day
    d: () => day(),
    dd: () => pad(day()),
    // Hours
    h: () => hours() % 12 || 12,
    hh: () => pad(hours() % 12 || 12),
    H: () => hours(),
    HH: () => pad(hours()),
    // Minutes
    m: () => minutes(),
    mm: () => pad(minutes()),
    // Seconds
    s: () => seconds(),
    ss: () => pad(seconds()),
    // Timezone as JS-compatible string
    X: () => timezone("minimal"),
    XX: () => timezone("basic"),
    XXX: () => timezone("extended")
  };
  return pattern.replaceAll(TOKEN, (match) => {
    if (match in matchers) {
      return matchers[match]();
    }
    return match.slice(1, -1);
  });
};
var createFormatDate = (localeData, defaultOptions) => {
  return (pattern, input = /* @__PURE__ */ new Date(), options) => {
    return _formatDate(pattern, toArray(localeData), input, mergeObjects(defaultOptions, options));
  };
};
var formatDate = createFormatDate([FORMAT_DATE_LOCALE_EN, FORMAT_DATE_LOCALE_RU], { utc: false, locale: "en" });
var formatDateRu = createFormatDate(FORMAT_DATE_LOCALE_RU, { utc: false, locale: "ru" });
var formatDateEn = createFormatDate(FORMAT_DATE_LOCALE_EN, { utc: false, locale: "en" });

// src/dates/is-iso-date/is-iso-date.ts
var isIsoDate = (input, strict = false) => {
  if (!isString(input))
    return false;
  const match = input.match(ISO_DATETIME_REG_EXP);
  if (!strict)
    return !!match;
  if (!match)
    return false;
  const [year, month, day] = match.slice(1).map(Number);
  const date = new Date(Date.UTC(year, month - 1, day, 0, 0, 0, 0));
  return date.getUTCMonth() === month - 1 && date.getUTCDate() === day;
};

// src/dates/is-leap-year/is-leap-year.ts
var isLeapYear = (value) => {
  const year = (() => {
    if (isInteger(value))
      return value;
    if (isString(value)) {
      const maybeNumber = +value;
      return Number.isNaN(maybeNumber) ? null : maybeNumber;
    }
    if (isDate(value, true))
      return value.getFullYear();
    return null;
  })();
  if (isNull(year))
    return false;
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};

// src/dates/random-date/random-date.ts
var setTime = (date, hours, minutes, seconds, milliseconds) => {
  hours = clamp(hours, 0, 23);
  minutes = clamp(minutes, 0, 59);
  seconds = clamp(seconds, 0, 59);
  milliseconds = clamp(milliseconds, 0, 999);
  date.setHours(hours);
  date.setMinutes(minutes);
  date.setSeconds(seconds);
  date.setMilliseconds(milliseconds);
};
var randomDate = (start = /* @__PURE__ */ new Date(0), end = /* @__PURE__ */ new Date(), userOptions) => {
  if (!isDate(start, true))
    start = /* @__PURE__ */ new Date(0);
  if (!isDate(end, true))
    end = /* @__PURE__ */ new Date();
  const date = new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
  if (isUndefined(userOptions))
    return date;
  if (isString(userOptions.time)) {
    const [time, milliseconds = 0] = userOptions.time.split(".");
    const [hours = 0, minutes = 0, seconds = 0] = time.split(":").map((maybeNumber) => {
      const number = Number(maybeNumber);
      return Number.isNaN(number) ? 0 : number;
    });
    setTime(date, hours, minutes, seconds, +milliseconds);
  }
  if (isArray(userOptions.time)) {
    const [hours = 0, minutes = 0, seconds = 0, milliseconds = 0] = userOptions.time;
    setTime(date, hours, minutes, seconds, milliseconds);
  }
  return date;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  FORMAT_DATE_LOCALE_EN,
  FORMAT_DATE_LOCALE_RU,
  createFormatDate,
  daysInMonth,
  formatDate,
  formatDateEn,
  formatDateRu,
  isIsoDate,
  isLeapYear,
  parseDate,
  randomDate,
  toDate
});
