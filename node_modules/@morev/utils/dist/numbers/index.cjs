"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/numbers/index.ts
var numbers_exports = {};
__export(numbers_exports, {
  clamp: () => clamp,
  formatBytes: () => formatBytes,
  formatBytesRu: () => formatBytesRu,
  numberFormat: () => numberFormat,
  precision: () => precision,
  randomFloat: () => randomFloat,
  randomInteger: () => randomInteger,
  toNumber: () => toNumber
});
module.exports = __toCommonJS(numbers_exports);

// src/numbers/clamp/clamp.ts
var clamp = (value, min = -Infinity, max = Infinity) => Math.max(
  min ?? -Infinity,
  Math.min(value, max ?? Infinity)
);

// src/guards/is-string/is-string.ts
var isString = (value) => Object.prototype.toString.call(value) === "[object String]";

// src/guards/is-object/is-object.ts
var isObject = (value) => Object.prototype.toString.call(value).includes("Object");

// src/guards/is-numeric/is-numeric.ts
var isNumeric = (value) => typeof value === "number" && !isNaN(value);

// src/guards/is-integer/is-integer.ts
var isInteger = (value) => Number.isInteger(value);

// src/arrays/array-of-length/array-of-length.ts
var arrayOfLength = (length, mapFunction) => {
  const neededLength = isInteger(length) && length > 0 ? length : 0;
  const arr = new Array(neededLength).fill(void 0);
  return mapFunction ? arr.map((_, index) => mapFunction(index)) : arr;
};

// src/numbers/random-integer/random-integer.ts
var randomInteger = (min = 1, max = Number.MAX_SAFE_INTEGER) => Math.floor(Math.random() * (max - min + 1)) + min;

// src/objects/merge-objects/merge-objects.ts
var _mergeObjects = (defaults, input, stack = "", merger) => {
  const result = { ...defaults };
  if (!isObject(input))
    return result;
  Object.entries(input).forEach(([key, val]) => {
    if (merger?.(result, key, val, stack))
      return;
    if (isObject(val) && isObject(result[key])) {
      Object.assign(result, { [key]: _mergeObjects(result[key], val, (stack ? `${stack}.` : "") + key, merger) });
    } else {
      Object.assign(result, { [key]: val });
    }
  });
  return result;
};
var createMergeObjects = (merger) => (...args) => args.reduce((p, c) => _mergeObjects(p, c, "", merger), {});
var mergeObjects = createMergeObjects();

// src/numbers/to-number/to-number.ts
function toNumber(value, fallback) {
  const throwOrReturnFallback = () => {
    if (arguments.length === 1) {
      throw new Error(`The value "${value}" cannot be converted to a number`);
    }
    return fallback;
  };
  if (isNumeric(value))
    return value;
  if (isString(value)) {
    const number = Number(value);
    return isNumeric(number) ? number : throwOrReturnFallback();
  }
  return throwOrReturnFallback();
}

// src/numbers/format-bytes/format-bytes.ts
var REFERENCE_TABLE = {
  metric: [
    { from: 0, to: 1e3, prefix: "b" },
    { from: 1e3, to: 1e6, prefix: "k" },
    { from: 1e6, to: 1e9, prefix: "m" },
    { from: 1e9, to: 1e12, prefix: "g" },
    { from: 1e12, to: 1e15, prefix: "t" },
    { from: 1e15, to: 1e18, prefix: "p" },
    { from: 1e18, to: 1e21, prefix: "e" },
    { from: 1e21, to: 1e24, prefix: "z" },
    { from: 1e24, to: 1e27, prefix: "y" }
  ],
  IEC: [
    { from: 0, to: 1024 ** 1, prefix: "b" },
    { from: 1024 ** 1, to: 1024 ** 2, prefix: "k" },
    { from: 1024 ** 2, to: 1024 ** 3, prefix: "m" },
    { from: 1024 ** 3, to: 1024 ** 4, prefix: "g" },
    { from: 1024 ** 4, to: 1024 ** 5, prefix: "t" },
    { from: 1024 ** 5, to: 1024 ** 6, prefix: "p" },
    { from: 1024 ** 6, to: 1024 ** 7, prefix: "e" },
    { from: 1024 ** 7, to: 1024 ** 8, prefix: "z" },
    { from: 1024 ** 8, to: 1024 ** 9, prefix: "y" }
  ]
};
var UNITS_DEFAULTS = {
  metric: {
    b: "B",
    k: "kB",
    m: "MB",
    g: "GB",
    t: "TB",
    p: "PB",
    e: "EB",
    z: "ZB",
    y: "YB"
  },
  IEC: {
    b: "B",
    k: "KiB",
    m: "MiB",
    g: "GiB",
    t: "TiB",
    p: "PiB",
    e: "EiB",
    z: "ZiB",
    y: "YiB"
  }
};
var DEFAULT_OPTIONS = {
  precision: 1,
  to: "auto",
  trimZeros: true,
  mode: "metric",
  toString: (value, valueAsString, unit, isInteger2) => `${valueAsString} ${unit}`
};
var _options = /* @__PURE__ */ new WeakMap();
var FormatBytes = class {
  /**
   * The calculated value.
   */
  value;
  /**
   * The calculated value in string form with needed precision.
   */
  valueAsString;
  /**
   * Calculated unit of value.
   */
  unit;
  /**
   * Whether the value is an integer number. \
   * Mostly used for `i18n` purposes.
   */
  isInteger;
  constructor(bytes, customOptions) {
    if (!isInteger(bytes))
      bytes = 0;
    const options = mergeObjects(DEFAULT_OPTIONS, customOptions);
    _options.set(this, options);
    const referenceTable = REFERENCE_TABLE[options.mode];
    const entry = options.to === "auto" ? referenceTable.find((e) => bytes >= e.from && bytes < e.to) ?? referenceTable[0] : referenceTable.find((i) => i.prefix === options.to) ?? referenceTable[0];
    const { from, prefix } = entry;
    const unitsReferenceTable = mergeObjects(UNITS_DEFAULTS, options.customUnits);
    const unit = unitsReferenceTable[options.mode][prefix];
    let value = bytes / from;
    value = Number.isFinite(value) ? value : bytes;
    let valueAsString = value.toFixed(options.precision);
    value = parseFloat(valueAsString);
    if (options.trimZeros) {
      value = parseFloat(valueAsString);
      valueAsString = value.toString();
    }
    const isInteger2 = isInteger(value);
    this.value = value;
    this.valueAsString = valueAsString;
    this.unit = unit;
    this.isInteger = isInteger2;
  }
  toString() {
    const { value, valueAsString, unit, isInteger: isInteger2 } = this;
    const options = _options.get(this);
    return options.toString(value, valueAsString, unit, isInteger2);
  }
};
var formatBytes = (bytes, customOptions) => new FormatBytes(bytes, customOptions);
var formatBytesRu = (bytes, _customOptions) => {
  const customOptions = mergeObjects({
    // Not sure actually, it's not reglamented ¯\_(ツ)_/¯
    customUnits: {
      metric: {
        b: "\u0411",
        k: "\u041A\u0411",
        m: "\u041C\u0411",
        g: "\u0413\u0411",
        t: "\u0422\u0411",
        p: "\u041F\u0411",
        e: "\u0415\u0411",
        z: "\u0417\u0411",
        y: "\u0418\u0411"
      },
      IEC: {
        b: "\u0411",
        k: "\u041A\u0431",
        m: "\u041C\u0431",
        g: "\u0413\u0431",
        t: "\u0422\u0431",
        p: "\u041F\u0431",
        e: "\u0415\u0431",
        z: "\u0417\u0431",
        y: "\u0418\u0431"
      }
    }
  }, _customOptions);
  return new FormatBytes(bytes, customOptions);
};

// src/numbers/number-format/number-format.ts
var numberFormat = (numberOrStringRepresentingNumber, decimals = 0, fractionSeparator = ".", thousandsSeparator = "\xA0") => {
  const number = toNumber(numberOrStringRepresentingNumber, 0);
  const toFixedFix = () => {
    const k = 10 ** decimals;
    return Math.round(number * k) / k;
  };
  const parts = String(decimals ? toFixedFix() : Math.round(number)).split(".");
  let [int, fraction = ""] = parts;
  if (int.length > 3) {
    int = int.replaceAll(/\B(?=(?:\d{3})+(?!\d))/g, thousandsSeparator);
  }
  if (fraction.length < decimals) {
    fraction += arrayOfLength(decimals - fraction.length + 1).join("0");
  }
  return [int, fraction].filter(Boolean).join(fractionSeparator);
};

// src/numbers/precision/precision.ts
var precision = (maybeNumber) => {
  const value = toNumber(maybeNumber, null);
  if (value === null || !Number.isFinite(value))
    return null;
  let e = 1;
  let p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p++;
  }
  return p;
};

// src/numbers/random-float/random-float.ts
var randomFloat = (min, max, precision2 = 1) => parseFloat((Math.random() * (max - min) + min).toFixed(precision2));
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  clamp,
  formatBytes,
  formatBytesRu,
  numberFormat,
  precision,
  randomFloat,
  randomInteger,
  toNumber
});
