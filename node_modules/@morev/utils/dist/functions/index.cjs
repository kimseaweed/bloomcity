"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/functions/index.ts
var functions_exports = {};
__export(functions_exports, {
  assert: () => assert,
  compose: () => compose,
  configureAssert: () => configureAssert,
  debounce: () => debounce,
  hash: () => hash,
  noop: () => noop,
  safeJsonParse: () => safeJsonParse,
  sleep: () => sleep,
  throttle: () => throttle,
  verifyFileAccept: () => verifyFileAccept,
  withProbability: () => withProbability
});
module.exports = __toCommonJS(functions_exports);

// src/guards/is-boolean/is-boolean.ts
var isBoolean = (value) => value === true || value === false;

// src/guards/is-string/is-string.ts
var isString = (value) => Object.prototype.toString.call(value) === "[object String]";

// src/guards/is-iterable/is-iterable.ts
var isIterable = (value) => (
  // eslint-disable-next-line unicorn/new-for-builtins
  Symbol.iterator in Object(value)
);

// src/guards/is-object/is-object.ts
var isObject = (value) => Object.prototype.toString.call(value).includes("Object");

// src/guards/is-empty/is-empty.ts
var isEmpty = (value) => {
  if (value === void 0)
    return true;
  if (value === null)
    return true;
  if (value === false)
    return true;
  if (Number.isNaN(value))
    return true;
  if (value === 0)
    return true;
  if (value === BigInt(0))
    return true;
  if (value === "")
    return true;
  if (isIterable(value) && typeof value === "object" && "length" in value && value.length === 0)
    return true;
  if (isIterable(value) && typeof value === "object" && "size" in value && value.size === 0)
    return true;
  if (isObject(value))
    return !Object.keys(value).length;
  return false;
};

// src/guards/is-function/is-function.ts
var isFunction = (value) => Object.prototype.toString.call(value) === "[object Function]";

// src/guards/is-null/is-null.ts
var isNull = (value) => value === null;

// src/guards/is-undefined/is-undefined.ts
var isUndefined = (value) => value === void 0;

// src/guards/is-nullish/is-nullish.ts
var isNullish = (value) => isNull(value) || isUndefined(value);

// src/functions/assert/assert.utils.ts
var typeMap = {
  "condition": "Assert condition failed",
  "no-value": "Assert value not undefined/null failed"
};
var messageFormatter = (failureType, message, properties) => {
  return [
    typeMap[failureType],
    message ? `: ${message}` : null,
    !isEmpty(properties) ? `: ${JSON.stringify(properties)}` : null
  ].filter(Boolean).join("");
};
var errorCreatorFactory = (formatter) => (failureType, message, properties) => new Error(formatter(failureType, message, properties));
var createConfiguration = () => ({
  formatter: messageFormatter,
  errorCreator: errorCreatorFactory(messageFormatter)
});

// src/functions/assert/assert.ts
var configuration = createConfiguration();
var _createAssert = (soft) => (conditionOrValue, message, properties) => {
  const createError = (type, props2) => configuration.errorCreator(type, message, props2);
  const report = (type, props2, error) => {
    error && configuration.errorReporter?.(type, error, message, props2);
    !error && configuration.warningReporter?.(type, message, props2);
  };
  const props = isFunction(properties) ? properties() : properties ?? {};
  if (isBoolean(conditionOrValue) && !conditionOrValue) {
    if (!soft) {
      const error = createError("condition", props);
      report("condition", props, error);
      throw error;
    }
    report("condition", props);
    return false;
  }
  if (isNullish(conditionOrValue)) {
    if (!soft) {
      const error = createError("no-value", props);
      report("no-value", props, error);
      throw error;
    }
    report("no-value", props);
    return false;
  }
  return conditionOrValue;
};
var hardAssert = _createAssert(false);
var softAssert = _createAssert(true);
var _assert = hardAssert;
_assert.soft = softAssert;
var assert = _assert;
var configureAssert = (customConfiguration) => {
  configuration = {
    ...configuration,
    ...customConfiguration,
    errorCreator: customConfiguration.errorCreator ?? errorCreatorFactory(customConfiguration.formatter ?? messageFormatter)
  };
};

// src/functions/compose/compose.ts
var compose = (...functions) => (value) => [...functions].reverse().reduce((acc, curr) => acc = curr(acc), value);

// src/functions/debounce/debounce.ts
var debounce = (fn, delay = 60, immediate = false) => {
  let timer;
  let started = false;
  const debounced = function(...args) {
    if (!started) {
      if (immediate)
        fn.apply(this, args);
      started = true;
    }
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
      started = false;
    }, delay);
  };
  return debounced;
};

// src/functions/hash/hash.ts
var import_ohash = require("ohash");
var hash = (value, options) => (0, import_ohash.hash)(value, options);

// src/functions/noop/noop.ts
var noop = () => {
};

// src/functions/safe-json-parse/safe-json-parse.ts
var safeJsonParse = (jsonString, reviver) => {
  if (!isString(jsonString))
    return null;
  try {
    return JSON.parse(jsonString, reviver);
  } catch {
    return null;
  }
};

// src/functions/sleep/sleep.ts
var sleep = async (duration = 0) => new Promise((resolve) => setTimeout(resolve, duration));

// src/functions/throttle/throttle.ts
var parseOptions = (optionsOrDelay) => {
  if (isObject(optionsOrDelay)) {
    return [
      optionsOrDelay.delay ?? 0,
      optionsOrDelay.leading ?? true,
      optionsOrDelay.trailing ?? true
    ];
  }
  return [optionsOrDelay ?? 0, true, true];
};
var throttle = (callback, optionsOrDelay) => {
  const [delay, leading, trailing] = parseOptions(optionsOrDelay);
  let timeoutID = null;
  let cancelled;
  let lastExec = leading ? 0 : Date.now();
  const clearExistingTimeout = () => {
    if (!timeoutID)
      return;
    clearTimeout(timeoutID);
    timeoutID = null;
  };
  const cancel = () => {
    clearExistingTimeout();
    cancelled = true;
  };
  const trailingExec = (exec) => {
    if (!trailing)
      return;
    clearExistingTimeout();
    timeoutID ||= setTimeout(exec, delay);
  };
  function wrapper(...args) {
    if (cancelled)
      return;
    const self = this;
    const exec = () => {
      lastExec = Date.now();
      callback.apply(self, args);
    };
    trailingExec(exec);
    const runTime = Date.now() - lastExec;
    if (runTime > delay)
      exec();
  }
  wrapper.cancel = cancel;
  return wrapper;
};

// src/functions/verify-file-accept/verify-file-accept.ts
var verifyFileAccept = (file, accept) => {
  if (!accept)
    return true;
  const parts = accept.split(",").map((part) => part.trim());
  const extensionParts = parts.filter((part) => part.startsWith("."));
  const mimeParts = parts.filter((part) => !part.startsWith(".")).join(",");
  const mimeResult = mimeParts ? new RegExp(mimeParts.replaceAll("*", ".*").replaceAll(",", "|")).test(file.type) : false;
  return mimeResult || extensionParts.some((part) => file.name.endsWith(part));
};

// src/numbers/clamp/clamp.ts
var clamp = (value, min = -Infinity, max = Infinity) => Math.max(
  min ?? -Infinity,
  Math.min(value, max ?? Infinity)
);

// src/functions/with-probability/with-probability.utils.ts
var toNumericProbability = (value) => {
  let isPercentage = false;
  if (isString(value)) {
    isPercentage = value.trim().endsWith("%");
    value = +value.replaceAll(/[^\d\-.]/g, "");
  }
  if (Number.isNaN(value))
    return 0;
  if (value > 1)
    isPercentage = true;
  if (isPercentage) {
    value = clamp(value, 0, 100);
    return value / 100;
  }
  return clamp(value, 0, 1);
};
var toValue = (value) => isFunction(value) ? value() : value;

// src/functions/with-probability/with-probability.ts
var withProbability = (probability, primaryValue, secondaryValue) => {
  if (probability === 1)
    return toValue(primaryValue);
  if (probability === 0)
    return toValue(secondaryValue);
  return Math.random() > toNumericProbability(probability) ? toValue(secondaryValue) : toValue(primaryValue);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assert,
  compose,
  configureAssert,
  debounce,
  hash,
  noop,
  safeJsonParse,
  sleep,
  throttle,
  verifyFileAccept,
  withProbability
});
