"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/colors/contrast-color/contrast-color.ts
var contrast_color_exports = {};
__export(contrast_color_exports, {
  contrastColor: () => contrastColor
});
module.exports = __toCommonJS(contrast_color_exports);

// src/guards/is-string/is-string.ts
var isString = (value) => Object.prototype.toString.call(value) === "[object String]";

// src/guards/is-hex/is-hex.ts
var isHex = (value) => {
  if (!isString(value))
    return false;
  return /^#(?:[\da-f]{8}|[\da-f]{6}|[\da-f]{4}|[\da-f]{3})$/i.test(value.toLowerCase());
};

// src/guards/is-null/is-null.ts
var isNull = (value) => value === null;

// src/guards/is-undefined/is-undefined.ts
var isUndefined = (value) => value === void 0;

// src/guards/is-nullish/is-nullish.ts
var isNullish = (value) => isNull(value) || isUndefined(value);

// src/colors/colors.utils.ts
var SHORT_HEX_REG_EXP = /^#([\da-f])([\da-f])([\da-f])([\da-f])?$/m;
var LONG_HEX_REG_EXP = /^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{0,2})$/m;

// src/colors/normalize-hex/normalize-hex.ts
var DEFAULT_OPTIONS = {
  notation: "long",
  alphaChannel: "always"
};
var normalizeHex = (hex, userOptions) => {
  hex = hex.trim().toLowerCase();
  if (!isHex(hex))
    return null;
  const options = { ...DEFAULT_OPTIONS, ...userOptions };
  const isShort = hex.length === 4 || hex.length === 5;
  const hasAlphaChannel = hex.length === 5 || hex.length === 9;
  const shouldAddAlphaChannel = options.alphaChannel === "always" || options.alphaChannel === "if-presented" && hasAlphaChannel;
  const parts = hex.replace(
    isShort ? SHORT_HEX_REG_EXP : LONG_HEX_REG_EXP,
    (_, r2, g2, b2, a2) => {
      if (isShort) {
        const alpha2 = !isNullish(a2) ? `${a2}${a2}` : `ff`;
        return `${r2}${r2}${g2}${g2}${b2}${b2}${alpha2}`;
      }
      return `${r2}${g2}${b2}${a2 || "ff"}`;
    }
  ).match(/.{2}/g);
  const [r, g, b, a] = parts;
  const rgb = options.notation === "short" ? (() => {
    const toCheck = [r, g, b, shouldAddAlphaChannel ? a : null].filter(Boolean);
    return toCheck.some((part) => !part.startsWith(part[1])) ? `#${r}${g}${b}` : `#${r[0]}${g[0]}${b[0]}`;
  })() : `#${r}${g}${b}`;
  if (!shouldAddAlphaChannel)
    return rgb;
  const alpha = rgb.length === 7 ? a : a[0];
  return `${rgb}${alpha}`;
};

// src/colors/hex-to-rgb/hex-to-rgb.ts
var DEFAULT_OPTIONS2 = {
  alphaChannel: "always",
  cssAlphaNotation: "percentage",
  returnType: "object-short"
};
var hexToRgb = (hex, userOptions) => {
  const options = { ...DEFAULT_OPTIONS2, ...userOptions };
  hex = normalizeHex(hex, { alphaChannel: options.alphaChannel, notation: "long" }) ?? "";
  if (!hex)
    return null;
  const shouldAddAlphaChannel = hex.length === 9;
  const parts = hex.slice(1).match(/.{2}/g);
  const parsed = parts.map((part, index) => {
    return index === 3 ? +(parseInt(part, 16) / 255).toFixed(2) : parseInt(part, 16);
  });
  const [r, g, b, a] = parsed;
  if (options.returnType === "object-short") {
    const base = { r, g, b };
    if (options.alphaChannel === "never")
      return base;
    return shouldAddAlphaChannel ? { ...base, a } : base;
  }
  if (options.returnType === "object-long") {
    const base = { red: r, green: g, blue: b };
    if (options.alphaChannel === "never")
      return base;
    return shouldAddAlphaChannel ? { ...base, alpha: a } : base;
  }
  if (options.returnType === "array") {
    const base = [r, g, b];
    shouldAddAlphaChannel && base.push(a);
    return base;
  }
  const prefix = shouldAddAlphaChannel ? `rgba` : `rgb`;
  const alphaPrefix = shouldAddAlphaChannel ? options.returnType === "css-legacy" ? `, ` : ` / ` : "";
  const alphaPart = shouldAddAlphaChannel ? options.cssAlphaNotation === "percentage" ? `${alphaPrefix}${a * 100}%` : `${alphaPrefix}${a}` : ``;
  return options.returnType === "css-legacy" ? `${prefix}(${r}, ${g}, ${b}${alphaPart})` : `${prefix}(${r} ${g} ${b}${alphaPart})`;
};

// src/colors/contrast-color/contrast-color.ts
var DEFAULT_CANDIDATES = ["#000000", "#ffffff"];
var getLuminance = (hexColor) => {
  const rgba = hexToRgb(hexColor, { alphaChannel: "never", returnType: "array" });
  if (!rgba)
    return null;
  const k = rgba.map((value) => {
    value /= 255;
    return value < 0.03928 ? value / 12.92 : ((value + 0.055) / 1.055) ** 2.4;
  });
  return 0.2126 * k[0] + 0.7152 * k[1] + 0.0722 * k[2];
};
var getContrast = (colorOne, colorTwo) => {
  const [luminance1, luminance2] = [getLuminance(colorOne), getLuminance(colorTwo)];
  if (isNull(luminance1) || isNull(luminance2))
    return null;
  const ratio = (luminance1 + 0.05) / (luminance2 + 0.05);
  return luminance2 > luminance1 ? 1 / ratio : ratio;
};
var DEFAULT_OPTIONS3 = {
  preferableNotation: "long"
};
var contrastColor = (sourceColor, userCandidates, userOptions) => {
  const options = { ...DEFAULT_OPTIONS3, ...userOptions };
  const candidates = userCandidates ?? DEFAULT_CANDIDATES;
  if (!isHex(sourceColor))
    return null;
  if (candidates.every((candidate) => !isHex(candidate)))
    return null;
  const contrasts = candidates.map((candidate) => getContrast(sourceColor, candidate)).filter(Boolean);
  const maxContrast = Math.max(...contrasts);
  const mostContrastColor = candidates[contrasts.indexOf(maxContrast)];
  if (options.preferableNotation === "preserve")
    return mostContrastColor;
  return normalizeHex(mostContrastColor, {
    alphaChannel: "never",
    notation: options.preferableNotation
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  contrastColor
});
