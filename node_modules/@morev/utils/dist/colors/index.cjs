"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/colors/index.ts
var colors_exports = {};
__export(colors_exports, {
  contrastColor: () => contrastColor,
  hexToRgb: () => hexToRgb,
  normalizeHex: () => normalizeHex,
  rgbToHex: () => rgbToHex
});
module.exports = __toCommonJS(colors_exports);

// src/guards/is-array/is-array.ts
var isArray = (value) => Array.isArray(value);

// src/guards/is-string/is-string.ts
var isString = (value) => Object.prototype.toString.call(value) === "[object String]";

// src/guards/is-object/is-object.ts
var isObject = (value) => Object.prototype.toString.call(value).includes("Object");

// src/guards/is-numeric/is-numeric.ts
var isNumeric = (value) => typeof value === "number" && !isNaN(value);

// src/guards/is-hex/is-hex.ts
var isHex = (value) => {
  if (!isString(value))
    return false;
  return /^#(?:[\da-f]{8}|[\da-f]{6}|[\da-f]{4}|[\da-f]{3})$/i.test(value.toLowerCase());
};

// src/guards/is-integer/is-integer.ts
var isInteger = (value) => Number.isInteger(value);

// src/guards/is-null/is-null.ts
var isNull = (value) => value === null;

// src/guards/is-undefined/is-undefined.ts
var isUndefined = (value) => value === void 0;

// src/guards/is-nullish/is-nullish.ts
var isNullish = (value) => isNull(value) || isUndefined(value);

// src/colors/colors.utils.ts
var SHORT_HEX_REG_EXP = /^#([\da-f])([\da-f])([\da-f])([\da-f])?$/m;
var LONG_HEX_REG_EXP = /^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{0,2})$/m;

// src/colors/normalize-hex/normalize-hex.ts
var DEFAULT_OPTIONS = {
  notation: "long",
  alphaChannel: "always"
};
var normalizeHex = (hex, userOptions) => {
  hex = hex.trim().toLowerCase();
  if (!isHex(hex))
    return null;
  const options = { ...DEFAULT_OPTIONS, ...userOptions };
  const isShort = hex.length === 4 || hex.length === 5;
  const hasAlphaChannel = hex.length === 5 || hex.length === 9;
  const shouldAddAlphaChannel = options.alphaChannel === "always" || options.alphaChannel === "if-presented" && hasAlphaChannel;
  const parts = hex.replace(
    isShort ? SHORT_HEX_REG_EXP : LONG_HEX_REG_EXP,
    (_, r2, g2, b2, a2) => {
      if (isShort) {
        const alpha2 = !isNullish(a2) ? `${a2}${a2}` : `ff`;
        return `${r2}${r2}${g2}${g2}${b2}${b2}${alpha2}`;
      }
      return `${r2}${g2}${b2}${a2 || "ff"}`;
    }
  ).match(/.{2}/g);
  const [r, g, b, a] = parts;
  const rgb = options.notation === "short" ? (() => {
    const toCheck = [r, g, b, shouldAddAlphaChannel ? a : null].filter(Boolean);
    return toCheck.some((part) => !part.startsWith(part[1])) ? `#${r}${g}${b}` : `#${r[0]}${g[0]}${b[0]}`;
  })() : `#${r}${g}${b}`;
  if (!shouldAddAlphaChannel)
    return rgb;
  const alpha = rgb.length === 7 ? a : a[0];
  return `${rgb}${alpha}`;
};

// src/colors/hex-to-rgb/hex-to-rgb.ts
var DEFAULT_OPTIONS2 = {
  alphaChannel: "always",
  cssAlphaNotation: "percentage",
  returnType: "object-short"
};
var hexToRgb = (hex, userOptions) => {
  const options = { ...DEFAULT_OPTIONS2, ...userOptions };
  hex = normalizeHex(hex, { alphaChannel: options.alphaChannel, notation: "long" }) ?? "";
  if (!hex)
    return null;
  const shouldAddAlphaChannel = hex.length === 9;
  const parts = hex.slice(1).match(/.{2}/g);
  const parsed = parts.map((part, index) => {
    return index === 3 ? +(parseInt(part, 16) / 255).toFixed(2) : parseInt(part, 16);
  });
  const [r, g, b, a] = parsed;
  if (options.returnType === "object-short") {
    const base = { r, g, b };
    if (options.alphaChannel === "never")
      return base;
    return shouldAddAlphaChannel ? { ...base, a } : base;
  }
  if (options.returnType === "object-long") {
    const base = { red: r, green: g, blue: b };
    if (options.alphaChannel === "never")
      return base;
    return shouldAddAlphaChannel ? { ...base, alpha: a } : base;
  }
  if (options.returnType === "array") {
    const base = [r, g, b];
    shouldAddAlphaChannel && base.push(a);
    return base;
  }
  const prefix = shouldAddAlphaChannel ? `rgba` : `rgb`;
  const alphaPrefix = shouldAddAlphaChannel ? options.returnType === "css-legacy" ? `, ` : ` / ` : "";
  const alphaPart = shouldAddAlphaChannel ? options.cssAlphaNotation === "percentage" ? `${alphaPrefix}${a * 100}%` : `${alphaPrefix}${a}` : ``;
  return options.returnType === "css-legacy" ? `${prefix}(${r}, ${g}, ${b}${alphaPart})` : `${prefix}(${r} ${g} ${b}${alphaPart})`;
};

// src/colors/contrast-color/contrast-color.ts
var DEFAULT_CANDIDATES = ["#000000", "#ffffff"];
var getLuminance = (hexColor) => {
  const rgba = hexToRgb(hexColor, { alphaChannel: "never", returnType: "array" });
  if (!rgba)
    return null;
  const k = rgba.map((value) => {
    value /= 255;
    return value < 0.03928 ? value / 12.92 : ((value + 0.055) / 1.055) ** 2.4;
  });
  return 0.2126 * k[0] + 0.7152 * k[1] + 0.0722 * k[2];
};
var getContrast = (colorOne, colorTwo) => {
  const [luminance1, luminance2] = [getLuminance(colorOne), getLuminance(colorTwo)];
  if (isNull(luminance1) || isNull(luminance2))
    return null;
  const ratio = (luminance1 + 0.05) / (luminance2 + 0.05);
  return luminance2 > luminance1 ? 1 / ratio : ratio;
};
var DEFAULT_OPTIONS3 = {
  preferableNotation: "long"
};
var contrastColor = (sourceColor, userCandidates, userOptions) => {
  const options = { ...DEFAULT_OPTIONS3, ...userOptions };
  const candidates = userCandidates ?? DEFAULT_CANDIDATES;
  if (!isHex(sourceColor))
    return null;
  if (candidates.every((candidate) => !isHex(candidate)))
    return null;
  const contrasts = candidates.map((candidate) => getContrast(sourceColor, candidate)).filter(Boolean);
  const maxContrast = Math.max(...contrasts);
  const mostContrastColor = candidates[contrasts.indexOf(maxContrast)];
  if (options.preferableNotation === "preserve")
    return mostContrastColor;
  return normalizeHex(mostContrastColor, {
    alphaChannel: "never",
    notation: options.preferableNotation
  });
};

// src/numbers/clamp/clamp.ts
var clamp = (value, min = -Infinity, max = Infinity) => Math.max(
  min ?? -Infinity,
  Math.min(value, max ?? Infinity)
);

// src/numbers/to-number/to-number.ts
function toNumber(value, fallback) {
  const throwOrReturnFallback = () => {
    if (arguments.length === 1) {
      throw new Error(`The value "${value}" cannot be converted to a number`);
    }
    return fallback;
  };
  if (isNumeric(value))
    return value;
  if (isString(value)) {
    const number = Number(value);
    return isNumeric(number) ? number : throwOrReturnFallback();
  }
  return throwOrReturnFallback();
}

// src/colors/rgb-to-hex/rgb-to-hex.ts
var CSS_REG_EXP = /^rgba?\(((?:\s*\d+\s*,?\s*){2}\d+)(\s*[,/]\s*-?[\d.]+%?)?\s*\);?$/m;
var DEFAULT_OPTIONS4 = {
  alphaChannel: "always",
  preferableNotation: "long"
};
var numberToHex = (part) => part.toString(16).padStart(2, "0");
var isValidRgbPart = (part) => isInteger(part) && part >= 0 && part <= 255;
var isValidAlphaPart = (part) => isNumeric(part) && part >= 0 && part <= 1;
var rgbToHex = (source, userOptions) => {
  const options = { ...DEFAULT_OPTIONS4, ...userOptions };
  const toHex = (r, g, b, a) => {
    const hex = `#${numberToHex(r)}${numberToHex(g)}${numberToHex(b)}${isNull(a) ? "" : numberToHex(a)}`;
    return normalizeHex(hex, {
      alphaChannel: options.alphaChannel,
      notation: options.preferableNotation
    });
  };
  if (isString(source)) {
    source = source.toLowerCase().trim();
    if (isHex([...source].join(""))) {
      source = normalizeHex(source, {
        notation: options.preferableNotation,
        alphaChannel: options.alphaChannel
      }) ?? "";
      return source || null;
    }
    if (!source.startsWith("rgb"))
      return null;
    const parts = source.replaceAll(/\s+/g, " ").match(CSS_REG_EXP);
    if (!parts)
      return null;
    const [_, rgb, alphaPart] = parts;
    const rgbParts = rgb.split(/ |, /).map((part) => parseInt(part, 10)).filter((part) => !Number.isNaN(part));
    if (rgbParts.length !== 3)
      return null;
    if (rgbParts.some((part) => !isValidRgbPart(part)))
      return null;
    const [r, g, b] = rgbParts;
    const a = (() => {
      if (!alphaPart)
        return null;
      const cleanAlphaPart = alphaPart.replaceAll(/[^\d%\-.]/g, "");
      if (cleanAlphaPart.endsWith("%")) {
        const percent = toNumber(alphaPart.replaceAll(/[^\d\-.]/g, ""), null);
        if (percent === null)
          return null;
        return Math.round(255 * clamp(percent, 0, 100) / 100);
      }
      const amount = toNumber(cleanAlphaPart, null);
      if (amount === null)
        return null;
      return Math.round(255 * clamp(amount, 0, 1));
    })();
    return toHex(r, g, b, a);
  }
  if (isArray(source)) {
    const cleanInput = source.map((part) => toNumber(part, null)).filter((part) => part !== null);
    if (cleanInput.length !== 3 && cleanInput.length !== 4)
      return null;
    if (cleanInput.slice(0, 3).some((part) => !isValidRgbPart(part)))
      return null;
    const alpha = cleanInput[3] ?? null;
    if (alpha !== null && !isValidAlphaPart(alpha))
      return null;
    const a = alpha === null ? null : Math.round(255 * alpha);
    return toHex(cleanInput[0], cleanInput[1], cleanInput[2], a);
  }
  if (isObject(source)) {
    let rgb = null;
    if ("r" in source && "g" in source && "b" in source) {
      rgb = { r: source.r, g: source.g, b: source.b, a: source.a };
    }
    if ("red" in source && "green" in source && "blue" in source) {
      rgb = { r: source.red, g: source.green, b: source.blue, a: source.alpha };
    }
    if (!rgb)
      return null;
    if ([rgb.r, rgb.g, rgb.b].some((value) => !isValidRgbPart(value)))
      return null;
    if (!isNullish(rgb.a) && !isValidAlphaPart(rgb.a))
      return null;
    const alpha = isNullish(rgb.a) ? null : Math.round(rgb.a * 255);
    return toHex(rgb.r, rgb.g, rgb.b, alpha);
  }
  return null;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  contrastColor,
  hexToRgb,
  normalizeHex,
  rgbToHex
});
