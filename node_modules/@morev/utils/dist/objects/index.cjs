"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/objects/index.ts
var objects_exports = {};
__export(objects_exports, {
  createMergeObjects: () => createMergeObjects,
  deepClone: () => deepClone,
  deepCloneStrict: () => deepCloneStrict,
  deepEqual: () => deepEqual,
  deepEqualCircular: () => deepEqualCircular,
  formDataToObject: () => formDataToObject,
  mergeObjects: () => mergeObjects,
  objectGet: () => objectGet,
  objectKeysCase: () => objectKeysCase,
  objectToFormdata: () => objectToFormdata,
  omit: () => omit,
  pick: () => pick,
  tsObject: () => tsObject
});
module.exports = __toCommonJS(objects_exports);

// src/objects/deep-clone/deep-clone.ts
var import_fast_copy = require("fast-copy");
var copy = (0, import_fast_copy.createCopier)({});
var deepClone = (value) => copy(value);
var deepCloneStrict = (value) => (0, import_fast_copy.copyStrict)(value);

// src/objects/deep-equal/deep-equal.ts
var import_fast_equals = require("fast-equals");
var deepEqual = (a, b) => (0, import_fast_equals.deepEqual)(a, b);
var deepEqualCircular = (a, b) => (0, import_fast_equals.circularDeepEqual)(a, b);

// src/guards/is-array/is-array.ts
var isArray = (value) => Array.isArray(value);

// src/guards/is-blob/is-blob.ts
var isBlob = (value) => {
  if (typeof Blob === "undefined")
    return false;
  return value instanceof Blob || Object.prototype.toString.call(value).includes("Blob");
};

// src/guards/is-boolean/is-boolean.ts
var isBoolean = (value) => value === true || value === false;

// src/guards/is-date/is-date.ts
var isDate = (value, checkValidity) => {
  const isDateObject = Object.prototype.toString.call(value).includes("Date");
  if (!isDateObject)
    return false;
  if (!checkValidity)
    return isDateObject;
  return !Number.isNaN(value.getTime());
};

// src/guards/is-string/is-string.ts
var isString = (value) => Object.prototype.toString.call(value) === "[object String]";

// src/guards/is-object/is-object.ts
var isObject = (value) => Object.prototype.toString.call(value).includes("Object");

// src/guards/is-file/is-file.ts
var isFile = (value) => {
  if (typeof File === "undefined")
    return false;
  return value instanceof File || Object.prototype.toString.call(value).includes("File");
};

// src/guards/is-numeric/is-numeric.ts
var isNumeric = (value) => typeof value === "number" && !isNaN(value);

// src/guards/is-form-data/is-form-data.ts
var isFormData = (value) => value instanceof FormData;

// src/guards/is-function/is-function.ts
var isFunction = (value) => Object.prototype.toString.call(value) === "[object Function]";

// src/guards/is-null/is-null.ts
var isNull = (value) => value === null;

// src/guards/is-undefined/is-undefined.ts
var isUndefined = (value) => value === void 0;

// src/guards/is-nullish/is-nullish.ts
var isNullish = (value) => isNull(value) || isUndefined(value);

// src/guards/is-reg-exp/is-reg-exp.ts
var isRegExp = (value) => Object.prototype.toString.call(value) === "[object RegExp]";

// src/arrays/to-array/to-array.ts
var toArray = (value) => [value].flat();

// src/objects/form-data-to-object/form-data-to-object.ts
var formDataToObject = (formData) => {
  if (!isFormData(formData))
    return formData;
  const result = {};
  for (const [key, value] of formData.entries()) {
    result[key] = key in result ? [...toArray(result[key]), value] : value;
  }
  return result;
};

// src/objects/merge-objects/merge-objects.ts
var _mergeObjects = (defaults, input, stack = "", merger) => {
  const result = { ...defaults };
  if (!isObject(input))
    return result;
  Object.entries(input).forEach(([key, val]) => {
    if (merger?.(result, key, val, stack))
      return;
    if (isObject(val) && isObject(result[key])) {
      Object.assign(result, { [key]: _mergeObjects(result[key], val, (stack ? `${stack}.` : "") + key, merger) });
    } else {
      Object.assign(result, { [key]: val });
    }
  });
  return result;
};
var createMergeObjects = (merger) => (...args) => args.reduce((p, c) => _mergeObjects(p, c, "", merger), {});
var mergeObjects = createMergeObjects();

// src/numbers/to-number/to-number.ts
function toNumber(value, fallback) {
  const throwOrReturnFallback = () => {
    if (arguments.length === 1) {
      throw new Error(`The value "${value}" cannot be converted to a number`);
    }
    return fallback;
  };
  if (isNumeric(value))
    return value;
  if (isString(value)) {
    const number = Number(value);
    return isNumeric(number) ? number : throwOrReturnFallback();
  }
  return throwOrReturnFallback();
}

// src/objects/object-get/object-get.ts
var extractSegments = (path) => toArray(path).map((p) => p.toString().trim()).flatMap((part) => part.replaceAll(/\[(.?)]/g, ".$1.").replaceAll(/\.+/g, ".").split(".").filter(Boolean).map((p) => toNumber(p, p)));
var objectGet = (input, path, defaultValue = void 0) => {
  if (!input || !isObject(input) && !isArray(input) || isNullish(path)) {
    return defaultValue;
  }
  const segments = extractSegments(path);
  let result = input;
  while (segments.length) {
    const property = segments.shift();
    if (!(property in result))
      return defaultValue;
    result = result[property];
  }
  return result;
};

// src/strings/camel-case/camel-case.ts
var UPPERCASE = /\p{Lu}/u;
var LOWERCASE = /\p{Ll}/u;
var LEADING_CAPITAL = /^\p{Lu}(?!\p{Lu})/gu;
var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
var SEPARATORS = /[ \-._]+/;
var LEADING_SEPARATORS = new RegExp(`^${SEPARATORS.source}`);
var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
var NUMBERS_AND_IDENTIFIER = new RegExp(`\\d+${IDENTIFIER.source}`, "gu");
var defaultOptions = {
  preserveConsecutiveUppercase: false
};
var preserveCamelCase = (string) => {
  let isLastCharLower = false;
  let isLastCharUpper = false;
  let isLastLastCharUpper = false;
  for (let i = 0; i < string.length; i++) {
    const character = string[i];
    if (isLastCharLower && UPPERCASE.test(character)) {
      string = `${string.slice(0, i)}-${string.slice(i)}`;
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      i++;
    } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
      string = `${string.slice(0, i - 1)}-${string.slice(i - 1)}`;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
    }
  }
  return string;
};
var preserveConsecutiveUppercase = (input) => {
  LEADING_CAPITAL.lastIndex = 0;
  return input.replaceAll(LEADING_CAPITAL, (m1) => m1.toLowerCase());
};
var postProcess = (input) => {
  SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
  NUMBERS_AND_IDENTIFIER.lastIndex = 0;
  return input.replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier) => identifier.toUpperCase()).replaceAll(NUMBERS_AND_IDENTIFIER, (m) => m.toUpperCase());
};
var camelCase = (input, options) => {
  if (!isArray(!input) && !isString(input)) {
    throw new TypeError("Expected the input to be `string | string[]`");
  }
  options = { ...defaultOptions, ...options };
  input = isArray(input) ? input.map((v) => v.trim()).filter(Boolean).join("-") : input.trim();
  if (!input.length)
    return "";
  if (input.length === 1)
    return input.toLowerCase();
  if (input !== input.toLowerCase()) {
    input = preserveCamelCase(input);
  }
  input = input.replace(LEADING_SEPARATORS, "");
  input = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input) : input.toLowerCase();
  return postProcess(input);
};

// src/strings/kebab-case/kebab-case.ts
var kebabCase = (input, _options) => {
  const options = { numbers: false, ..._options };
  let result = input.replaceAll(/([a-z])([A-Z])/g, "$1-$2").replaceAll(/[\s._]+/g, "-");
  if (!options.numbers)
    return result.toLowerCase();
  result = result.replace(/\d+/, "-$&").replaceAll(/(\d)([A-Z])/g, "$1-$2");
  return result.startsWith("-") ? result.slice(1).toLowerCase() : result.toLowerCase();
};

// src/strings/pascal-case/pascal-case.ts
var defaultOptions2 = {
  preserveConsecutiveUppercase: false
};
var pascalCase = (input, options) => {
  const base = camelCase(input, { ...defaultOptions2, ...options });
  if (!base.length)
    return "";
  return base[0].toUpperCase() + base.slice(1);
};

// src/strings/snake-case/snake-case.ts
var snakeCase = (input) => input.replaceAll(/([a-z])([A-Z])/g, "$1-$2").replaceAll(/[\s\-.]+/g, "_").toLowerCase();

// src/objects/object-keys-case/object-keys-case.ts
var getPath = (path, ...parts) => path ? `${path}.${parts.join(".")}` : parts.join(".");
var getHandler = (neededCase) => {
  switch (neededCase) {
    case "snake_case":
      return snakeCase;
    case "PascalCase":
      return pascalCase;
    case "camelCase":
      return camelCase;
    case "kebab-case":
      return kebabCase;
    default:
      return (v) => v;
  }
};
var objectKeysCase = (input, neededCase, _options) => {
  const options = {
    depth: Infinity,
    exclude: [],
    excludeBranches: [],
    ..._options
  };
  const handler = getHandler(neededCase);
  const isExcluded = (type, key) => {
    const entity = type === "key" ? options.exclude : options.excludeBranches;
    return entity.some((item) => {
      if (isString(item))
        return item === key;
      if (isRegExp(item))
        return item.test(key);
      return false;
    });
  };
  const isDepthAllowed = (depth) => options.depth > depth;
  const processEntry = (entry, path, depth) => {
    if (!isObject(entry) && !isArray(entry))
      return entry;
    const isEntryArray = isArray(entry);
    return Object.entries(entry).reduce((acc, [_key, _value]) => {
      const shouldTransformKey = !isExcluded("key", _key) && !isExcluded("branch", getPath(path, _key)) && isDepthAllowed(depth);
      const shouldTransformValue = !isExcluded("branch", getPath(path, _key)) && isDepthAllowed(depth + 1);
      const key = shouldTransformKey ? handler(_key) : _key;
      const value = shouldTransformValue ? processEntry(_value, getPath(path, _key), depth + 1) : _value;
      if (isEntryArray)
        acc.push(value);
      if (!isEntryArray)
        acc[key] = value;
      return acc;
    }, isEntryArray ? [] : {});
  };
  return processEntry(input, "", 0);
};

// src/objects/ts-object/ts-object.ts
var tsObject = {
  /**
   * Typed version of `Object.keys()`.
   *
   * @param   obj   Object to process.
   *
   * @returns       `Object.keys()` return value for a given object.
   */
  keys: (obj) => Object.keys(obj),
  /**
   * Typed version of `Object.values()`.
   *
   * @param   obj   Object to process.
   *
   * @returns       `Object.values()` return value for a given object.
   */
  values: (obj) => Object.values(obj),
  /**
   * Typed version of `Object.entries()`.
   *
   * @param   obj   Object to process.
   *
   * @returns       `Object.entries()` return value for a given object.
   */
  entries: (obj) => Object.entries(obj),
  /**
   * Typed version of `Object.fromEntries()`.
   *
   * @param   entries   Entries to process.
   *
   * @returns           `Object.fromEntries()` return value for a given object.
   */
  fromEntries: (entries) => Object.fromEntries(entries)
};

// src/objects/object-to-formdata/object-to-formdata.ts
var DEFAULT_OPTIONS = {
  indices: false,
  nullValues: "omit",
  booleanValues: "preserve-as-strings",
  emptyArrays: "omit",
  arrayBrackets: "append",
  objectKeysNotation: "brackets"
};
var serialize = (key, value, options, formData) => {
  if (isUndefined(value))
    return;
  if (isNull(value)) {
    if (options.nullValues === "omit")
      return;
    const realValue = options.nullValues === "preserve-as-empty-string" ? "" : "null";
    formData.append(key, realValue);
    return;
  }
  if (isDate(value)) {
    formData.append(key, value.toISOString());
    return;
  }
  if (isBoolean(value)) {
    const realValue = options.booleanValues === "preserve-as-integers" ? value ? "1" : "0" : value.toString();
    formData.append(key, realValue);
    return;
  }
  if (isArray(value)) {
    if (!value.length) {
      if (options.emptyArrays === "preserve") {
        formData.append(key, "");
      }
      return;
    }
    const isFilesArray = value.every((innerValue) => isFile(innerValue));
    value.forEach((arrayValue, index) => {
      const arrayKey = (() => {
        if (options.arrayBrackets === "append" || options.arrayBrackets === "append-only-for-files" && isFilesArray)
          return `${key}[${options.indices ? index : ""}]`;
        return key.replaceAll(/\[]$/gm, "");
      })();
      serialize(arrayKey, arrayValue, options, formData);
    });
    return;
  }
  if (isBlob(value)) {
    formData.append(key, value);
    return;
  }
  if (isObject(value)) {
    tsObject.entries(value).forEach(([innerKey, innerValue]) => {
      const realInnerKey = (() => {
        if (!key)
          return innerKey;
        return options.objectKeysNotation === "brackets" ? `${key}[${innerKey}]` : `${key}.${innerKey}`;
      })();
      serialize(realInnerKey, innerValue, options, formData);
    });
    return;
  }
  if (isNumeric(value)) {
    formData.append(key, value.toString());
    return;
  }
  if (isString(value) || isFunction(value?.toString)) {
    formData.append(key, value.toString());
  }
};
var objectToFormdata = (object, userOptions, existingFormData) => {
  const options = { ...DEFAULT_OPTIONS, ...userOptions };
  const formData = existingFormData ?? new FormData();
  serialize("", object, options, formData);
  return formData;
};

// src/objects/omit/omit.ts
var omit = (obj, ...keys) => Object.fromEntries(Object.entries(obj ?? {}).filter(([k]) => !keys.includes(k)));

// src/objects/pick/pick.ts
var pick = (obj, ...keys) => Object.fromEntries(
  keys.filter((key) => key in obj).map((key) => [key, obj[key]])
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createMergeObjects,
  deepClone,
  deepCloneStrict,
  deepEqual,
  deepEqualCircular,
  formDataToObject,
  mergeObjects,
  objectGet,
  objectKeysCase,
  objectToFormdata,
  omit,
  pick,
  tsObject
});
